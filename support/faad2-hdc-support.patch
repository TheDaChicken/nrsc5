diff --git a/CMakeLists.txt b/CMakeLists.txt
index 97b61cc..5956418 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -146,7 +146,7 @@ endif()  # GCC
 file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/include/neaacdec.h
      DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/include)

-foreach(LIB faad faad_drm faad_fixed faad_drm_fixed)
+foreach(LIB faad faad_drm faad_hdc faad_fixed faad_drm_fixed)
   add_library(${LIB} ${LIBFAAD_SOURCES})
   if(MATH_LIBRARY)
     target_link_libraries(${LIB} PUBLIC ${MATH_LIBRARY})
@@ -171,6 +171,12 @@ target_compile_definitions(${LIB} PRIVATE
 )
 endforeach()

+foreach(LIB faad_hdc)
+  target_compile_definitions(${LIB} PRIVATE
+          HDC_SUPPORT
+  )
+endforeach()
+
 foreach(LIB faad_fixed faad_drm_fixed)
 target_compile_definitions(${LIB} PRIVATE
   FIXED_POINT
@@ -271,7 +277,7 @@ if(NOT FAAD_BUNDLED_MODE)
   install(FILES "${CMAKE_CURRENT_BINARY_DIR}/faad2.pc"
     DESTINATION "${CMAKE_INSTALL_LIBDIR}/pkgconfig")

-  set(INSTALL_TARGETS faad faad_drm)
+  set(INSTALL_TARGETS faad faad_drm faad_hdc)
   if (FAAD_BUILD_CLI)
     list(APPEND INSTALL_TARGETS faad_cli)
   endif()
diff --git a/frontend/main.c b/frontend/main.c
index 895ed18..18aefb7 100644
--- a/frontend/main.c
+++ b/frontend/main.c
@@ -1164,7 +1164,8 @@ static int faad_main(int argc, char *argv[])
                     if ((val != LC) &&
                         (val != MAIN) &&
                         (val != LTP) &&
-                        (val != LD))
+                        (val != LD) &&
+                        (val != HDC_LC))
                     {
                         showHelp = 1;
                     }
diff --git a/include/neaacdec.h b/include/neaacdec.h
index f7d5f67..4743441 100644
--- a/include/neaacdec.h
+++ b/include/neaacdec.h
@@ -60,7 +60,7 @@ extern "C" {

 #ifdef _WIN32
   #pragma pack(push, 8)
-  #define NEAACDECAPI __declspec(dllexport)
+  #define NEAACDECAPI
 #elif defined(__GNUC__) && __GNUC__ >= 4
   #define NEAACDECAPI __attribute__((visibility("default")))
 #else
@@ -81,6 +81,7 @@ extern "C" {
 #define ER_LTP    19
 #define LD        23
 #define DRM_ER_LC 27 /* special object type for DRM */
+#define HDC_LC    127 /* non standard type for HDC */

 /* header types */
 #define RAW        0
@@ -227,6 +228,9 @@ NEAACDECAPI char NeAACDecInit2(NeAACDecHandle hDecoder,
 NEAACDECAPI char NeAACDecInitDRM(NeAACDecHandle *hDecoder, unsigned long samplerate,
                                  unsigned char channels);

+/* Init the library for HDC */
+NEAACDECAPI char NeAACDecInitHDC(NeAACDecHandle *hDecoder);
+
 NEAACDECAPI void NeAACDecPostSeekReset(NeAACDecHandle hDecoder, long frame);

 NEAACDECAPI void NeAACDecClose(NeAACDecHandle hDecoder);
@@ -236,6 +240,13 @@ NEAACDECAPI void* NeAACDecDecode(NeAACDecHandle hDecoder,
                                  unsigned char *buffer,
                                  unsigned long buffer_size);

+NEAACDECAPI void* NeAACDecDecodeHDC(NeAACDecHandle hpDecoder,
+                                 NeAACDecFrameInfo *hInfo,
+                                 unsigned char *buffer,
+                                 unsigned long buffer_size,
+                                 unsigned char *enh_buffer,
+                                 unsigned long enh_buffer_size);
+
 NEAACDECAPI void* NeAACDecDecode2(NeAACDecHandle hDecoder,
                                   NeAACDecFrameInfo *hInfo,
                                   unsigned char *buffer,
diff --git a/libfaad/bits.c b/libfaad/bits.c
index 110c9dc..ee37aff 100644
--- a/libfaad/bits.c
+++ b/libfaad/bits.c
@@ -244,7 +244,7 @@ uint8_t *faad_getbitbuffer(bitfile *ld, uint32_t bits
     return buffer;
 }

-#ifdef DRM
+#if defined(DRM) || defined(HDC)
 /* return the original data buffer */
 void *faad_origbitbuffer(bitfile *ld)
 {
diff --git a/libfaad/bits.h b/libfaad/bits.h
index c01c54e..44ea3fa 100644
--- a/libfaad/bits.h
+++ b/libfaad/bits.h
@@ -87,7 +87,7 @@ void faad_rewindbits(bitfile *ld);
 void faad_resetbits(bitfile *ld, uint32_t bits);
 uint8_t *faad_getbitbuffer(bitfile *ld, uint32_t bits
                        DEBUGDEC);
-#ifdef DRM
+#if defined(DRM) || defined(HDC)
 void *faad_origbitbuffer(bitfile *ld);
 uint32_t faad_origbitbuffer_size(bitfile *ld);
 #endif
diff --git a/libfaad/common.c b/libfaad/common.c
index 1f4a7d1..70d83a4 100644
--- a/libfaad/common.c
+++ b/libfaad/common.c
@@ -165,6 +165,11 @@ int8_t can_decode_ot(const uint8_t object_type)
 #else
         return -1;
 #endif
+#endif
+
+#ifdef HDC
+    case HDC_LC:
+        return 0;
 #endif
     }

diff --git a/libfaad/common.h b/libfaad/common.h
index aba8e90..d6a5c59 100644
--- a/libfaad/common.h
+++ b/libfaad/common.h
@@ -95,6 +95,12 @@ extern "C" {
 #define DRM
 #define DRM_PS
 #endif
+/* Allow decoding of HDC */
+#ifdef HDC_SUPPORT
+#define DRM
+#define DRM_PS
+#define HDC
+#endif

 /* LD can't do without LTP */
 #ifdef LD_DEC
diff --git a/libfaad/decoder.c b/libfaad/decoder.c
index de3b169..78de890 100644
--- a/libfaad/decoder.c
+++ b/libfaad/decoder.c
@@ -63,7 +63,9 @@ static void* aac_frame_decode(NeAACDecStruct *hDecoder,
                               unsigned char *buffer,
                               unsigned long buffer_size,
                               void **sample_buffer2,
-                              unsigned long sample_buffer_size);
+                              unsigned long sample_buffer_size,
+                              unsigned char *enh_buffer,
+                              unsigned long enh_buffer_size);
 static void create_channel_config(NeAACDecStruct *hDecoder,
                                   NeAACDecFrameInfo *hInfo);

@@ -350,6 +352,13 @@ long NeAACDecInit(NeAACDecHandle hpDecoder,
     if (!*samplerate)
         return -1;

+#ifdef HDC
+    if (hDecoder->config.defObjectType == HDC_LC)
+    {
+        hDecoder->object_type = hDecoder->config.defObjectType;
+    }
+#endif
+
 #if (defined(PS_DEC) || defined(DRM_PS))
     /* check if we have a mono file */
     if (*channels == 1)
@@ -529,6 +538,38 @@ char NeAACDecInitDRM(NeAACDecHandle *hpDecoder,
 }
 #endif

+#ifdef HDC
+char NeAACDecInitHDC(NeAACDecHandle *hpDecoder)
+{
+    NeAACDecStruct** hDecoder = (NeAACDecStruct**)hpDecoder;
+    if (hDecoder == NULL)
+        return 1; /* error */
+
+    NeAACDecClose(*hDecoder);
+
+    *hDecoder = NeAACDecOpen();
+
+    /* Special object type defined for HDC */
+    (*hDecoder)->config.defObjectType = HDC_LC;
+
+    (*hDecoder)->config.defSampleRate = 22050;
+#ifdef ERROR_RESILIENCE
+    (*hDecoder)->aacSectionDataResilienceFlag = 0;
+    (*hDecoder)->aacScalefactorDataResilienceFlag = 0;
+    (*hDecoder)->aacSpectralDataResilienceFlag = 0;
+#endif
+    (*hDecoder)->frameLength = 1024;
+    (*hDecoder)->sf_index = get_sr_index((*hDecoder)->config.defSampleRate);
+    (*hDecoder)->object_type = (*hDecoder)->config.defObjectType;
+
+    (*hDecoder)->channelConfiguration = 2;
+    (*hDecoder)->forceUpSampling = 1;
+
+    (*hDecoder)->fb = filter_bank_init((*hDecoder)->frameLength);
+    return 0;
+}
+#endif
+
 void NeAACDecClose(NeAACDecHandle hpDecoder)
 {
     uint8_t i;
@@ -824,7 +865,20 @@ void* NeAACDecDecode(NeAACDecHandle hpDecoder,
                                  unsigned long buffer_size)
 {
     NeAACDecStruct* hDecoder = (NeAACDecStruct*)hpDecoder;
-    return aac_frame_decode(hDecoder, hInfo, buffer, buffer_size, NULL, 0);
+    return aac_frame_decode(hDecoder, hInfo, buffer, buffer_size, NULL, 0,
+        NULL, 0);
+}
+
+void* NeAACDecDecodeHDC(NeAACDecHandle hpDecoder,
+                                 NeAACDecFrameInfo *hInfo,
+                                 unsigned char *buffer,
+                                 unsigned long buffer_size,
+                                 unsigned char *enh_buffer,
+                                 unsigned long enh_buffer_size)
+{
+    NeAACDecStruct* hDecoder = (NeAACDecStruct*)hpDecoder;
+    return aac_frame_decode(hDecoder, hInfo, buffer, buffer_size, NULL, 0,
+        enh_buffer, enh_buffer_size);
 }

 void* NeAACDecDecode2(NeAACDecHandle hpDecoder,
@@ -842,7 +896,7 @@ void* NeAACDecDecode2(NeAACDecHandle hpDecoder,
     }

     return aac_frame_decode(hDecoder, hInfo, buffer, buffer_size,
-        sample_buffer, sample_buffer_size);
+        sample_buffer, sample_buffer_size, NULL, 0);
 }

 static void* aac_frame_decode(NeAACDecStruct *hDecoder,
@@ -850,7 +904,9 @@ static void* aac_frame_decode(NeAACDecStruct *hDecoder,
                               unsigned char *buffer,
                               unsigned long buffer_size,
                               void **sample_buffer2,
-                              unsigned long sample_buffer_size)
+                              unsigned long sample_buffer_size,
+                              unsigned char *enh_buffer,
+                              unsigned long enh_buffer_size)
 {
     uint16_t i;
     uint8_t channels = 0;
@@ -987,7 +1043,29 @@ static void* aac_frame_decode(NeAACDecStruct *hDecoder,
         DRM_aac_scalable_main_element(hDecoder, hInfo, &ld, &hDecoder->pce, hDecoder->drc);
     } else {
 #endif
-        raw_data_block(hDecoder, hInfo, &ld, &hDecoder->pce, hDecoder->drc);
+
+#ifdef HDC
+        if (hDecoder->object_type == HDC_LC)
+        {
+            bitfile enh;
+            if (enh_buffer)
+            {
+                /* initialize the bitstream */
+                faad_initbits(&enh, enh_buffer, enh_buffer_size);
+                if (enh.error != 0)
+                    return NULL;
+            }
+
+            hdc_data_block(hDecoder, hInfo, &ld, enh_buffer ? &enh : NULL, &hDecoder->pce, hDecoder->drc);
+        } else {
+#endif
+
+            raw_data_block(hDecoder, hInfo, &ld, &hDecoder->pce, hDecoder->drc);
+
+#ifdef HDC
+        }
+#endif
+
 #ifdef DRM
     }
 #endif
diff --git a/libfaad/drm_dec.c b/libfaad/drm_dec.c
index 1a24aca..5cea492 100644
--- a/libfaad/drm_dec.c
+++ b/libfaad/drm_dec.c
@@ -44,6 +44,9 @@
 #define DECAY_CUTOFF         3
 #define DECAY_SLOPE          0.05f

+/* macros */
+#define IS_HDC(num_subsamples) ((num_subsamples) == 32)
+
 /* type definitaions */
 typedef const int8_t (*drm_ps_huff_tab)[2];

@@ -225,6 +228,30 @@ static const real_t pan_pow_2_30_neg[8][5] = {
     { COEF_CONST(0.969764715), COEF_CONST(0.947691892), COEF_CONST(0.922571949), COEF_CONST(0.898117847), COEF_CONST(0.874311936) }
 };

+/* 2^(pan_quant[x][y]/32) */
+static const real_t pan_pow_2_32_pos[8][5] = {
+    { COEF_CONST(1),           COEF_CONST(1),           COEF_CONST(1),           COEF_CONST(1),           COEF_CONST(1)           },
+    { COEF_CONST(1.003604347), COEF_CONST(1.003604347), COEF_CONST(1.007221686), COEF_CONST(1.007221686), COEF_CONST(1.007221686) },
+    { COEF_CONST(1.007221686), COEF_CONST(1.007221686), COEF_CONST(1.014495524), COEF_CONST(1.018152118), COEF_CONST(1.018152118) },
+    { COEF_CONST(1.010852062), COEF_CONST(1.014495524), COEF_CONST(1.021821892), COEF_CONST(1.032910767), COEF_CONST(1.036633736) },
+    { COEF_CONST(1.014495524), COEF_CONST(1.021821892), COEF_CONST(1.032910767), COEF_CONST(1.04788335),  COEF_CONST(1.055448548) },
+    { COEF_CONST(1.018152118), COEF_CONST(1.029201168), COEF_CONST(1.04788335),  COEF_CONST(1.066902341), COEF_CONST(1.078480432) },
+    { COEF_CONST(1.021821892), COEF_CONST(1.040370124), COEF_CONST(1.063070665), COEF_CONST(1.086268878), COEF_CONST(1.105986959) },
+    { COEF_CONST(1.029201168), COEF_CONST(1.051658007), COEF_CONST(1.078480432), COEF_CONST(1.105986959), COEF_CONST(1.134195038) }
+};
+
+/* 2^(-pan_quant[x][y]/32) */
+static const real_t pan_pow_2_32_neg[8][5] = {
+    { COEF_CONST(1),           COEF_CONST(1),           COEF_CONST(1),           COEF_CONST(1),           COEF_CONST(1)           },
+    { COEF_CONST(0.996408597), COEF_CONST(0.996408597), COEF_CONST(0.992830093), COEF_CONST(0.992830093), COEF_CONST(0.992830093) },
+    { COEF_CONST(0.992830093), COEF_CONST(0.992830093), COEF_CONST(0.985711594), COEF_CONST(0.982171507), COEF_CONST(0.982171507) },
+    { COEF_CONST(0.989264441), COEF_CONST(0.985711594), COEF_CONST(0.978644134), COEF_CONST(0.968137841), COEF_CONST(0.964660869) },
+    { COEF_CONST(0.985711594), COEF_CONST(0.978644134), COEF_CONST(0.968137841), COEF_CONST(0.954304695), COEF_CONST(0.947464471) },
+    { COEF_CONST(0.982171507), COEF_CONST(0.971627346), COEF_CONST(0.954304695), COEF_CONST(0.93729291),  COEF_CONST(0.927230546) },
+    { COEF_CONST(0.978644134), COEF_CONST(0.961196383), COEF_CONST(0.940671239), COEF_CONST(0.92058239),  COEF_CONST(0.904169793) },
+    { COEF_CONST(0.971627346), COEF_CONST(0.950879462), COEF_CONST(0.927230546), COEF_CONST(0.904169793), COEF_CONST(0.881682573) }
+};
+
 static const real_t g_decayslope[MAX_SA_BAND] = {
     FRAC_CONST(1),   FRAC_CONST(1),   FRAC_CONST(1),   FRAC_CONST(0.95),FRAC_CONST(0.9), FRAC_CONST(0.85), FRAC_CONST(0.8),
     FRAC_CONST(0.75),FRAC_CONST(0.7), FRAC_CONST(0.65),FRAC_CONST(0.6), FRAC_CONST(0.55),FRAC_CONST(0.5),  FRAC_CONST(0.45),
@@ -635,7 +662,7 @@ static void drm_ps_delta_decode(drm_ps_info *ps)
     }
 }

-static void drm_calc_sa_side_signal(drm_ps_info *ps, qmf_t X[38][64])
+static void drm_calc_sa_side_signal(drm_ps_info *ps, qmf_t X[38][64], int num_subsamples)
 {
     uint8_t s, b, k;
     complex_t qfrac, tmp0, tmp, in, R0;
@@ -659,7 +686,7 @@ static void drm_calc_sa_side_signal(drm_ps_info *ps, qmf_t X[38][64])
         RE(Phi_Fract) = RE(Phi_Fract_Qmf[b]);
         IM(Phi_Fract) = IM(Phi_Fract_Qmf[b]);

-        for (s = 0; s < NUM_OF_SUBSAMPLES; s++)
+        for (s = 0; s < num_subsamples; s++)
         {
             const real_t gamma = REAL_CONST(1.5);
             const real_t sigma = REAL_CONST(1.5625);
@@ -750,19 +777,21 @@ static void drm_calc_sa_side_signal(drm_ps_info *ps, qmf_t X[38][64])
         ps->delay_buf_index_ser[k] = temp_delay_ser[k];
 }

-static void drm_add_ambiance(drm_ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64])
+static void drm_add_ambiance(drm_ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64], int num_subsamples)
 {
-    uint8_t s, b, ifreq, qclass;
+    uint8_t s, b, ifreq, qclass, is_hdc;
     real_t sa_map[MAX_SA_BAND], sa_dir_map[MAX_SA_BAND], k_sa_map[MAX_SA_BAND], k_sa_dir_map[MAX_SA_BAND];
     real_t new_dir_map, new_sa_map;

+    is_hdc = IS_HDC(num_subsamples);
+
     if (ps->bs_enable_sa)
     {
         /* Instead of dequantization and mapping, we use an inverse mapping
            to look up all the values we need */
         for (b = 0; b < sa_freq_scale[DRM_NUM_SA_BANDS]; b++)
         {
-            const real_t inv_f_num_of_subsamples = FRAC_CONST(0.03333333333);
+            const real_t inv_f_num_of_subsamples = is_hdc ? FRAC_CONST(0.03125) : FRAC_CONST(0.03333333333);

             ifreq = sa_inv_freq[b];
             qclass = (b != 0);
@@ -779,7 +808,7 @@ static void drm_add_ambiance(drm_ps_info *ps, qmf_t X_left[38][64], qmf_t X_righ

         }

-        for (s = 0; s < NUM_OF_SUBSAMPLES; s++)
+        for (s = 0; s < num_subsamples; s++)
         {
             for (b = 0; b < sa_freq_scale[DRM_NUM_SA_BANDS]; b++)
             {
@@ -799,7 +828,7 @@ static void drm_add_ambiance(drm_ps_info *ps, qmf_t X_left[38][64], qmf_t X_righ
         }
     }
     else {
-        for (s = 0; s < NUM_OF_SUBSAMPLES; s++)
+        for (s = 0; s < num_subsamples; s++)
         {
             for (b = 0; b < NUM_OF_QMF_CHANNELS; b++)
             {
@@ -810,14 +839,16 @@ static void drm_add_ambiance(drm_ps_info *ps, qmf_t X_left[38][64], qmf_t X_righ
     }
 }

-static void drm_add_pan(drm_ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64])
+static void drm_add_pan(drm_ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64], int num_subsamples)
 {
-    uint8_t s, b, qclass, ifreq;
+    uint8_t s, b, qclass, ifreq, is_hdc;
     real_t tmp, coeff1, coeff2;
     real_t pan_base[MAX_PAN_BAND];
     real_t pan_delta[MAX_PAN_BAND];
     qmf_t temp_l, temp_r;

+    is_hdc = IS_HDC(num_subsamples);
+
     if (ps->bs_enable_pan)
     {
         for (b = 0; b < NUM_OF_QMF_CHANNELS; b++)
@@ -834,31 +865,56 @@ static void drm_add_pan(drm_ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38]
                 pan_base[b] = pan_pow_2_neg[-ps->g_prev_pan_index[ifreq]][qclass];
             }

-            /* 2^((a-b)/30) = 2^(a/30) * 1/(2^(b/30)) */
+            /* 2^((a-b)/32) = 2^(a/32) * 1/(2^(b/32)) if HDC */
+            /* 2^((a-b)/30) = 2^(a/30) * 1/(2^(b/30)) if regular DRM */
             /* a en b can be negative so we may need to inverse parts */
             if (ps->g_pan_index[ifreq] >= 0)
             {
                 if (ps->g_prev_pan_index[ifreq] >= 0)
                 {
-                    pan_delta[b] = MUL_C(pan_pow_2_30_pos[ps->g_pan_index[ifreq]][qclass],
-                                         pan_pow_2_30_neg[ps->g_prev_pan_index[ifreq]][qclass]);
+                    if (is_hdc)
+                    {
+                        pan_delta[b] = MUL_C(pan_pow_2_32_pos[ps->g_pan_index[ifreq]][qclass],
+                                             pan_pow_2_32_neg[ps->g_prev_pan_index[ifreq]][qclass]);
+                    } else {
+                        pan_delta[b] = MUL_C(pan_pow_2_30_pos[ps->g_pan_index[ifreq]][qclass],
+                                             pan_pow_2_30_neg[ps->g_prev_pan_index[ifreq]][qclass]);
+                    }
                 } else {
-                    pan_delta[b] = MUL_C(pan_pow_2_30_pos[ps->g_pan_index[ifreq]][qclass],
-                                         pan_pow_2_30_pos[-ps->g_prev_pan_index[ifreq]][qclass]);
+                    if (is_hdc)
+                    {
+                        pan_delta[b] = MUL_C(pan_pow_2_32_pos[ps->g_pan_index[ifreq]][qclass],
+                                             pan_pow_2_32_pos[-ps->g_prev_pan_index[ifreq]][qclass]);
+                    } else {
+                        pan_delta[b] = MUL_C(pan_pow_2_30_pos[ps->g_pan_index[ifreq]][qclass],
+                                             pan_pow_2_30_pos[-ps->g_prev_pan_index[ifreq]][qclass]);
+                    }
                 }
             } else {
                 if (ps->g_prev_pan_index[ifreq] >= 0)
                 {
-                    pan_delta[b] = MUL_C(pan_pow_2_30_neg[-ps->g_pan_index[ifreq]][qclass],
-                                         pan_pow_2_30_neg[ps->g_prev_pan_index[ifreq]][qclass]);
+                    if (is_hdc)
+                    {
+                        pan_delta[b] = MUL_C(pan_pow_2_32_neg[-ps->g_pan_index[ifreq]][qclass],
+                                             pan_pow_2_32_neg[ps->g_prev_pan_index[ifreq]][qclass]);
+                    } else {
+                        pan_delta[b] = MUL_C(pan_pow_2_30_neg[-ps->g_pan_index[ifreq]][qclass],
+                                             pan_pow_2_30_neg[ps->g_prev_pan_index[ifreq]][qclass]);
+                    }
                 } else {
-                    pan_delta[b] = MUL_C(pan_pow_2_30_neg[-ps->g_pan_index[ifreq]][qclass],
-                                         pan_pow_2_30_pos[-ps->g_prev_pan_index[ifreq]][qclass]);
+                    if (is_hdc)
+                    {
+                        pan_delta[b] = MUL_C(pan_pow_2_32_neg[-ps->g_pan_index[ifreq]][qclass],
+                                             pan_pow_2_32_pos[-ps->g_prev_pan_index[ifreq]][qclass]);
+                    } else {
+                        pan_delta[b] = MUL_C(pan_pow_2_30_neg[-ps->g_pan_index[ifreq]][qclass],
+                                             pan_pow_2_30_pos[-ps->g_prev_pan_index[ifreq]][qclass]);
+                    }
                 }
             }
         }

-        for (s = 0; s < NUM_OF_SUBSAMPLES; s++)
+        for (s = 0; s < num_subsamples; s++)
         {
             /* PAN always uses all 64 channels */
             for (b = 0; b < NUM_OF_QMF_CHANNELS; b++)
@@ -901,17 +957,19 @@ void drm_ps_free(drm_ps_info *ps)
 }

 /* main DRM PS decoding function */
-uint8_t drm_ps_decode(drm_ps_info *ps, uint8_t guess, qmf_t X_left[38][64], qmf_t X_right[38][64])
+uint8_t drm_ps_decode(drm_ps_info *ps, uint8_t guess, qmf_t X_left[38][64], qmf_t X_right[38][64], uint8_t hdc_sbr)
 {
+    int num_subsamples = hdc_sbr ? NUM_OF_HDC_SUBSAMPLES : NUM_OF_SUBSAMPLES;
+
     if (ps == NULL)
     {
-        memcpy(X_right, X_left, sizeof(qmf_t)*30*64);
+        memcpy(X_right, X_left, sizeof(qmf_t)*num_subsamples*64);
         return 0;
     }

     if (!ps->drm_ps_data_available && !guess)
     {
-        memcpy(X_right, X_left, sizeof(qmf_t)*30*64);
+        memcpy(X_right, X_left, sizeof(qmf_t)*num_subsamples*64);
         memset(ps->g_prev_sa_index, 0, sizeof(ps->g_prev_sa_index));
         memset(ps->g_prev_pan_index, 0, sizeof(ps->g_prev_pan_index));
         return 0;
@@ -933,8 +991,8 @@ uint8_t drm_ps_decode(drm_ps_info *ps, uint8_t guess, qmf_t X_left[38][64], qmf_

     ps->drm_ps_data_available = 0;

-    drm_calc_sa_side_signal(ps, X_left);
-    drm_add_ambiance(ps, X_left, X_right);
+    drm_calc_sa_side_signal(ps, X_left, num_subsamples);
+    drm_add_ambiance(ps, X_left, X_right, num_subsamples);

     if (ps->bs_enable_sa)
     {
@@ -948,7 +1006,7 @@ uint8_t drm_ps_decode(drm_ps_info *ps, uint8_t guess, qmf_t X_left[38][64], qmf_

     if (ps->bs_enable_pan)
     {
-        drm_add_pan(ps, X_left, X_right);
+        drm_add_pan(ps, X_left, X_right, num_subsamples);

         ps->g_last_had_pan = 1;

diff --git a/libfaad/drm_dec.h b/libfaad/drm_dec.h
index 62276a9..56a4b3d 100644
--- a/libfaad/drm_dec.h
+++ b/libfaad/drm_dec.h
@@ -43,6 +43,7 @@ extern "C" {
 #define NUM_OF_LINKS             3
 #define NUM_OF_QMF_CHANNELS     64
 #define NUM_OF_SUBSAMPLES       30
+#define NUM_OF_HDC_SUBSAMPLES   32
 #define MAX_SA_BAND             46
 #define MAX_PAN_BAND            64
 #define MAX_DELAY                5
@@ -75,7 +76,7 @@ typedef struct

     uint8_t delay_buf_index_ser[NUM_OF_LINKS];

-    qmf_t SA[NUM_OF_SUBSAMPLES][MAX_SA_BAND];
+    qmf_t SA[NUM_OF_HDC_SUBSAMPLES][MAX_SA_BAND];

     complex_t d_buff[2][MAX_SA_BAND];
     complex_t d2_buff[NUM_OF_LINKS][MAX_DELAY][MAX_SA_BAND];
@@ -91,7 +92,7 @@ uint16_t drm_ps_data(drm_ps_info *ps, bitfile *ld);
 drm_ps_info *drm_ps_init(void);
 void drm_ps_free(drm_ps_info *ps);

-uint8_t drm_ps_decode(drm_ps_info *ps, uint8_t guess, qmf_t X_left[38][64], qmf_t X_right[38][64]);
+uint8_t drm_ps_decode(drm_ps_info *ps, uint8_t guess, qmf_t X_left[38][64], qmf_t X_right[38][64], uint8_t hdc_sdr);

 #ifdef __cplusplus
 }
diff --git a/libfaad/sbr_dec.c b/libfaad/sbr_dec.c
index d301e66..4c96d6f 100644
--- a/libfaad/sbr_dec.c
+++ b/libfaad/sbr_dec.c
@@ -453,18 +453,22 @@ static uint8_t sbr_process_channel(sbr_info *sbr, real_t *channel_buf, qmf_t X[M
     return ret;
 }

-uint8_t sbrDecodeCoupleFrame(sbr_info *sbr, real_t *left_chan, real_t *right_chan,
-                             const uint8_t just_seeked, const uint8_t downSampledSBR)
+uint8_t sbrDecodeFrames(sbr_info *sbr, int input_channels, real_t* channels[2],
+                       const uint8_t just_seeked, const uint8_t downSampledSBR,
+                       const int ps_used)
 {
     uint8_t dont_process = 0;
     uint8_t ret = 0;
-    ALIGN qmf_t X[MAX_NTSRHFG][64];
+    ALIGN qmf_t X[2][MAX_NTSRHFG][64] = {0};

     if (sbr == NULL)
         return 20;

     /* case can occur due to bit errors */
-    if (sbr->id_aac != ID_CPE)
+    if (input_channels == 2 && sbr->id_aac != ID_CPE)
+        return 21;
+
+    if (input_channels == 1 && sbr->id_aac != ID_SCE && sbr->id_aac != ID_LFE)
         return 21;

     if (sbr->ret || (sbr->header_count == 0))
@@ -484,96 +488,71 @@ uint8_t sbrDecodeCoupleFrame(sbr_info *sbr, real_t *left_chan, real_t *right_cha
         sbr->just_seeked = 0;
     }

-    sbr->ret += sbr_process_channel(sbr, left_chan, X, 0, dont_process, downSampledSBR);
-    /* subband synthesis */
-    if (downSampledSBR)
-    {
-        sbr_qmf_synthesis_32(sbr, sbr->qmfs[0], X, left_chan);
-    } else {
-        sbr_qmf_synthesis_64(sbr, sbr->qmfs[0], X, left_chan);
-    }
-
-    sbr->ret += sbr_process_channel(sbr, right_chan, X, 1, dont_process, downSampledSBR);
-    /* subband synthesis */
-    if (downSampledSBR)
+    if (sbr->qmfs[1] == NULL)
     {
-        sbr_qmf_synthesis_32(sbr, sbr->qmfs[1], X, right_chan);
-    } else {
-        sbr_qmf_synthesis_64(sbr, sbr->qmfs[1], X, right_chan);
+        sbr->qmfs[1] = qmfs_init((downSampledSBR)?32:64);
     }

-    if (sbr->bs_header_flag)
-        sbr->just_seeked = 0;
+    int synth_channels = input_channels;

-    if (sbr->header_count != 0 && sbr->ret == 0)
+    for (int i = 0; i < input_channels; i++)
     {
-        ret = sbr_save_prev_data(sbr, 0);
-        if (ret) return ret;
-        ret = sbr_save_prev_data(sbr, 1);
-        if (ret) return ret;
-    }
-
-    sbr_save_matrix(sbr, 0);
-    sbr_save_matrix(sbr, 1);
+        real_t* chan = channels[i];

-    sbr->frame++;
+        sbr->ret += sbr_process_channel(sbr, chan, X[i],
+            i, dont_process, downSampledSBR);
+    }

-//#define POST_QMF_PRINT
-#ifdef POST_QMF_PRINT
+    if (input_channels == 1 && ps_used)
     {
-        int i;
-        for (i = 0; i < 2048; i++)
+        uint8_t l, k;
+
+        /* copy some extra data for PS */
+        for (l = sbr->numTimeSlotsRate; l < sbr->numTimeSlotsRate + 6; l++)
         {
-            printf("%d\n", left_chan[i]);
+            for (k = 0; k < 5; k++)
+            {
+                QMF_RE(X[0][l][k]) = QMF_RE(sbr->Xsbr[0][sbr->tHFAdj+l][k]);
+                QMF_IM(X[0][l][k]) = QMF_IM(sbr->Xsbr[0][sbr->tHFAdj+l][k]);
+            }
         }
-        for (i = 0; i < 2048; i++)
+
+        /* perform parametric stereo */
+#ifdef DRM_PS
+#ifdef HDC
+        if (sbr->Is_DRM_SBR || sbr->Is_HDC_SBR)
+#else
+        if (sbr->Is_DRM_SBR)
+#endif
         {
-            printf("%d\n", right_chan[i]);
+#ifdef HDC
+            drm_ps_decode(sbr->drm_ps, (sbr->ret > 0), X[0], X[1], sbr->Is_HDC_SBR);
+#else
+            drm_ps_decode(sbr->drm_ps, (sbr->ret > 0), X[0], X[1], 0);
+#endif
+        } else {
+#endif
+#ifdef PS_DEC
+            ps_decode(sbr->ps, X[0], X[1]);
+#endif
+#ifdef DRM_PS
         }
-    }
 #endif

-    return 0;
-}
-
-uint8_t sbrDecodeSingleFrame(sbr_info *sbr, real_t *channel,
-                             const uint8_t just_seeked, const uint8_t downSampledSBR)
-{
-    uint8_t dont_process = 0;
-    uint8_t ret = 0;
-    ALIGN qmf_t X[MAX_NTSRHFG][64];
-
-    if (sbr == NULL)
-        return 20;
-
-    /* case can occur due to bit errors */
-    if (sbr->id_aac != ID_SCE && sbr->id_aac != ID_LFE)
-        return 21;
-
-    if (sbr->ret || (sbr->header_count == 0))
-    {
-        /* don't process just upsample */
-        dont_process = 1;
-
-        /* Re-activate reset for next frame */
-        if (sbr->ret && sbr->Reset)
-            sbr->bs_start_freq_prev = INVALID;
+        synth_channels = 2;
     }

-    if (just_seeked)
+    for (int i = 0; i < synth_channels; i++)
     {
-        sbr->just_seeked = 1;
-    } else {
-        sbr->just_seeked = 0;
-    }
+        real_t* chan = channels[i];

-    sbr->ret += sbr_process_channel(sbr, channel, X, 0, dont_process, downSampledSBR);
-    /* subband synthesis */
-    if (downSampledSBR)
-    {
-        sbr_qmf_synthesis_32(sbr, sbr->qmfs[0], X, channel);
-    } else {
-        sbr_qmf_synthesis_64(sbr, sbr->qmfs[0], X, channel);
+        /* subband synthesis */
+        if (downSampledSBR)
+        {
+            sbr_qmf_synthesis_32(sbr, sbr->qmfs[i], X[i], chan);
+        } else {
+            sbr_qmf_synthesis_64(sbr, sbr->qmfs[i], X[i], chan);
+        }
     }

     if (sbr->bs_header_flag)
@@ -581,11 +560,17 @@ uint8_t sbrDecodeSingleFrame(sbr_info *sbr, real_t *channel,

     if (sbr->header_count != 0 && sbr->ret == 0)
     {
-        ret = sbr_save_prev_data(sbr, 0);
-        if (ret) return ret;
+        for (int i = 0; i < input_channels; i++)
+        {
+            ret = sbr_save_prev_data(sbr, i);
+            if (ret) return ret;
+        }
     }

-    sbr_save_matrix(sbr, 0);
+    for (int i = 0; i < input_channels; i++)
+    {
+        sbr_save_matrix(sbr, i);
+    }

     sbr->frame++;

@@ -595,104 +580,16 @@ uint8_t sbrDecodeSingleFrame(sbr_info *sbr, real_t *channel,
         int i;
         for (i = 0; i < 2048; i++)
         {
-            printf("%d\n", channel[i]);
+            printf("%d\n", left_chan[i]);
         }
-    }
-#endif
-
-    return 0;
-}
-
-#if (defined(PS_DEC) || defined(DRM_PS))
-uint8_t sbrDecodeSingleFramePS(sbr_info *sbr, real_t *left_channel, real_t *right_channel,
-                               const uint8_t just_seeked, const uint8_t downSampledSBR)
-{
-    uint8_t l, k;
-    uint8_t dont_process = 0;
-    uint8_t ret = 0;
-    ALIGN qmf_t X_left[MAX_NTSRHFG][64] = {{{0}}};
-    ALIGN qmf_t X_right[MAX_NTSRHFG][64] = {{{0}}}; /* must set this to 0 */
-
-    if (sbr == NULL)
-        return 20;
-
-    /* case can occur due to bit errors */
-    if (sbr->id_aac != ID_SCE && sbr->id_aac != ID_LFE)
-        return 21;
-
-    if (sbr->ret || (sbr->header_count == 0))
-    {
-        /* don't process just upsample */
-        dont_process = 1;
-
-        /* Re-activate reset for next frame */
-        if (sbr->ret && sbr->Reset)
-            sbr->bs_start_freq_prev = INVALID;
-    }
-
-    if (just_seeked)
-    {
-        sbr->just_seeked = 1;
-    } else {
-        sbr->just_seeked = 0;
-    }
-
-    if (sbr->qmfs[1] == NULL)
-    {
-        sbr->qmfs[1] = qmfs_init((downSampledSBR)?32:64);
-    }
-
-    sbr->ret += sbr_process_channel(sbr, left_channel, X_left, 0, dont_process, downSampledSBR);
-
-    /* copy some extra data for PS */
-    for (l = sbr->numTimeSlotsRate; l < sbr->numTimeSlotsRate + 6; l++)
-    {
-        for (k = 0; k < 5; k++)
+        for (i = 0; i < 2048; i++)
         {
-            QMF_RE(X_left[l][k]) = QMF_RE(sbr->Xsbr[0][sbr->tHFAdj+l][k]);
-            QMF_IM(X_left[l][k]) = QMF_IM(sbr->Xsbr[0][sbr->tHFAdj+l][k]);
+            printf("%d\n", right_chan[i]);
         }
     }
-
-    /* perform parametric stereo */
-#ifdef DRM_PS
-    if (sbr->Is_DRM_SBR)
-    {
-        drm_ps_decode(sbr->drm_ps, (sbr->ret > 0), X_left, X_right);
-    } else {
-#endif
-#ifdef PS_DEC
-        ps_decode(sbr->ps, X_left, X_right);
-#endif
-#ifdef DRM_PS
-    }
 #endif

-    /* subband synthesis */
-    if (downSampledSBR)
-    {
-        sbr_qmf_synthesis_32(sbr, sbr->qmfs[0], X_left, left_channel);
-        sbr_qmf_synthesis_32(sbr, sbr->qmfs[1], X_right, right_channel);
-    } else {
-        sbr_qmf_synthesis_64(sbr, sbr->qmfs[0], X_left, left_channel);
-        sbr_qmf_synthesis_64(sbr, sbr->qmfs[1], X_right, right_channel);
-    }
-
-    if (sbr->bs_header_flag)
-        sbr->just_seeked = 0;
-
-    if (sbr->header_count != 0 && sbr->ret == 0)
-    {
-        ret = sbr_save_prev_data(sbr, 0);
-        if (ret) return ret;
-    }
-
-    sbr_save_matrix(sbr, 0);
-
-    sbr->frame++;
-
     return 0;
 }
-#endif

 #endif
diff --git a/libfaad/sbr_dec.h b/libfaad/sbr_dec.h
index 40e53ae..e0cf3b1 100644
--- a/libfaad/sbr_dec.h
+++ b/libfaad/sbr_dec.h
@@ -176,6 +176,10 @@ typedef struct
     ps_info *ps;
 #endif

+#ifdef HDC
+    uint8_t Is_HDC_SBR;
+#endif
+
     uint8_t numTimeSlotsRate;
     uint8_t numTimeSlots;
     uint8_t tHFGen;
@@ -241,15 +245,8 @@ sbr_info *sbrDecodeInit(uint16_t framelength, uint8_t id_aac,
 void sbrDecodeEnd(sbr_info *sbr);
 void sbrReset(sbr_info *sbr);

-uint8_t sbrDecodeCoupleFrame(sbr_info *sbr, real_t *left_chan, real_t *right_chan,
-                             const uint8_t just_seeked, const uint8_t downSampledSBR);
-uint8_t sbrDecodeSingleFrame(sbr_info *sbr, real_t *channel,
-                             const uint8_t just_seeked, const uint8_t downSampledSBR);
-#if (defined(PS_DEC) || defined(DRM_PS))
-uint8_t sbrDecodeSingleFramePS(sbr_info *sbr, real_t *left_channel, real_t *right_channel,
-                               const uint8_t just_seeked, const uint8_t downSampledSBR);
-#endif
-
+uint8_t sbrDecodeFrames(sbr_info *sbr, int input_channels, real_t* channels[2],
+                             const uint8_t just_seeked, const uint8_t downSampledSBR, int ps_used);

 #ifdef __cplusplus
 }
diff --git a/libfaad/sbr_syntax.c b/libfaad/sbr_syntax.c
index e27980f..4c2b91c 100644
--- a/libfaad/sbr_syntax.c
+++ b/libfaad/sbr_syntax.c
@@ -153,7 +153,11 @@ uint8_t sbr_extension_data(bitfile *ld, sbr_info *sbr, uint16_t cnt,
 #endif

 #ifdef DRM
+#ifdef HDC
+    if (!sbr->Is_DRM_SBR && !sbr->Is_HDC_SBR)
+#else
     if (!sbr->Is_DRM_SBR)
+#endif
 #endif
     {
         uint8_t bs_extension_type = (uint8_t)faad_getbits(ld, 4
@@ -246,7 +250,11 @@ uint8_t sbr_extension_data(bitfile *ld, sbr_info *sbr, uint16_t cnt,
     }

 #ifdef DRM
+#ifdef HDC
+    if (!sbr->Is_DRM_SBR && !sbr->Is_HDC_SBR)
+#else
     if (!sbr->Is_DRM_SBR)
+#endif
 #endif
     {
         /* -4 does not apply, bs_extension_type is re-read in this function */
@@ -391,6 +399,12 @@ static uint8_t sbr_single_channel_element(bitfile *ld, sbr_info *sbr)
         faad_get1bit(ld);
     }
 #endif
+#ifdef HDC
+    if (sbr->Is_HDC_SBR)
+    {
+        faad_get1bit(ld);
+    }
+#endif

     if ((result = sbr_grid(ld, sbr, 0)) > 0)
         return result;
@@ -888,7 +902,11 @@ static uint16_t sbr_extension(bitfile *ld, sbr_info *sbr,
 #ifdef DRM_PS
     case DRM_PARAMETRIC_STEREO:
         /* If not expected then only decode but do not expose. */
+#ifdef HDC
+        if (sbr->Is_DRM_SBR || sbr->Is_HDC_SBR)
+#else
         if (sbr->Is_DRM_SBR)
+#endif
         {
             sbr->ps_used = 1;
         }
@@ -899,9 +917,9 @@ static uint16_t sbr_extension(bitfile *ld, sbr_info *sbr,
         return drm_ps_data(sbr->drm_ps, ld);
 #endif
     default:
-        sbr->bs_extension_data = (uint8_t)faad_getbits(ld, 6
-            DEBUGVAR(1,279,"sbr_single_channel_element(): bs_extension_data"));
-        return 6;
+        sbr->bs_extension_data = (uint8_t)faad_getbits(ld, num_bits_left
+             DEBUGVAR(1,279,"sbr_single_channel_element(): bs_extension_data"));
+        return num_bits_left;
     }
 }

diff --git a/libfaad/specrec.c b/libfaad/specrec.c
index 94cee17..b08241a 100644
--- a/libfaad/specrec.c
+++ b/libfaad/specrec.c
@@ -694,11 +694,33 @@ static uint8_t quant_to_spec(NeAACDecStruct *hDecoder,
     return error;
 }

-static uint8_t allocate_single_channel(NeAACDecStruct *hDecoder, uint8_t channel,
-                                       uint8_t output_channels)
+static uint8_t allocate_time_channel(NeAACDecStruct *hDecoder, const uint8_t channel)
 {
     int mul = 1;

+    if (hDecoder->time_out[channel] != NULL)
+    {
+        faad_free(hDecoder->time_out[channel]);
+        hDecoder->time_out[channel] = NULL;
+    }
+
+    {
+#ifdef SBR_DEC
+        if (hDecoder->sbr_alloced[hDecoder->fr_ch_ele] == 1)
+        {
+            /* SBR requires 2 times as much output data */
+            mul = 2;
+        }
+#endif
+        hDecoder->time_out[channel] = (real_t*)faad_malloc(mul*hDecoder->frameLength*sizeof(real_t));
+        memset(hDecoder->time_out[channel], 0, mul*hDecoder->frameLength*sizeof(real_t));
+    }
+
+    return 0;
+}
+
+static uint8_t allocate_single_channel(NeAACDecStruct *hDecoder, uint8_t channel)
+{
 #ifdef MAIN_DEC
     /* MAIN object type prediction */
     if (hDecoder->object_type == MAIN)
@@ -730,40 +752,16 @@ static uint8_t allocate_single_channel(NeAACDecStruct *hDecoder, uint8_t channel
     }
 #endif

-    if (hDecoder->time_out[channel] != NULL)
-    {
-        faad_free(hDecoder->time_out[channel]);
-        hDecoder->time_out[channel] = NULL;
-    }
-
+    hDecoder->sbr_alloced[hDecoder->fr_ch_ele] = 0;
+    if ((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
     {
-        mul = 1;
-#ifdef SBR_DEC
-        hDecoder->sbr_alloced[hDecoder->fr_ch_ele] = 0;
-        if ((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
-        {
-            /* SBR requires 2 times as much output data */
-            mul = 2;
-            hDecoder->sbr_alloced[hDecoder->fr_ch_ele] = 1;
-        }
-#endif
-        hDecoder->time_out[channel] = (real_t*)faad_malloc(mul*hDecoder->frameLength*sizeof(real_t));
-        memset(hDecoder->time_out[channel], 0, mul*hDecoder->frameLength*sizeof(real_t));
+        /* SBR requires 2 times as much output data */
+        hDecoder->sbr_alloced[hDecoder->fr_ch_ele] = 1;
     }

-#if (defined(PS_DEC) || defined(DRM_PS))
-    if (output_channels == 2)
-    {
-        if (hDecoder->time_out[channel+1] != NULL)
-        {
-            faad_free(hDecoder->time_out[channel+1]);
-            hDecoder->time_out[channel+1] = NULL;
-        }
-
-        hDecoder->time_out[channel+1] = (real_t*)faad_malloc(mul*hDecoder->frameLength*sizeof(real_t));
-        memset(hDecoder->time_out[channel+1], 0, mul*hDecoder->frameLength*sizeof(real_t));
-    }
-#endif
+    const uint8_t retval = allocate_time_channel(hDecoder, channel);
+    if (retval > 0)
+        return retval;

     if (hDecoder->fb_intermed[channel] != NULL)
     {
@@ -795,176 +793,17 @@ static uint8_t allocate_single_channel(NeAACDecStruct *hDecoder, uint8_t channel
     return 0;
 }

-static uint8_t allocate_channel_pair(NeAACDecStruct *hDecoder,
-                                     uint8_t channel, uint8_t paired_channel)
-{
-    int mul = 1;
-
-#ifdef MAIN_DEC
-    /* MAIN object type prediction */
-    if (hDecoder->object_type == MAIN)
-    {
-        /* allocate the state only when needed */
-        if (hDecoder->pred_stat[channel] == NULL)
-        {
-            hDecoder->pred_stat[channel] = (pred_state*)faad_malloc(hDecoder->frameLength * sizeof(pred_state));
-            reset_all_predictors(hDecoder->pred_stat[channel], hDecoder->frameLength);
-        }
-        if (hDecoder->pred_stat[paired_channel] == NULL)
-        {
-            hDecoder->pred_stat[paired_channel] = (pred_state*)faad_malloc(hDecoder->frameLength * sizeof(pred_state));
-            reset_all_predictors(hDecoder->pred_stat[paired_channel], hDecoder->frameLength);
-        }
-    }
-#endif
-
-#ifdef LTP_DEC
-    if (is_ltp_ot(hDecoder->object_type))
-    {
-        /* allocate the state only when needed */
-        if (hDecoder->lt_pred_stat[channel] == NULL)
-        {
-            hDecoder->lt_pred_stat[channel] = (int16_t*)faad_malloc(hDecoder->frameLength*4 * sizeof(int16_t));
-            memset(hDecoder->lt_pred_stat[channel], 0, hDecoder->frameLength*4 * sizeof(int16_t));
-        }
-        if (hDecoder->lt_pred_stat[paired_channel] == NULL)
-        {
-            hDecoder->lt_pred_stat[paired_channel] = (int16_t*)faad_malloc(hDecoder->frameLength*4 * sizeof(int16_t));
-            memset(hDecoder->lt_pred_stat[paired_channel], 0, hDecoder->frameLength*4 * sizeof(int16_t));
-        }
-    }
-#endif
-
-    {
-        mul = 1;
-#ifdef SBR_DEC
-        hDecoder->sbr_alloced[hDecoder->fr_ch_ele] = 0;
-        if ((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
-        {
-            /* SBR requires 2 times as much output data */
-            mul = 2;
-            hDecoder->sbr_alloced[hDecoder->fr_ch_ele] = 1;
-        }
-#endif
-    }
-    if (hDecoder->time_out[channel] == NULL)
-    {
-        hDecoder->time_out[channel] = (real_t*)faad_malloc(mul*hDecoder->frameLength*sizeof(real_t));
-        memset(hDecoder->time_out[channel], 0, mul*hDecoder->frameLength*sizeof(real_t));
-    }
-    if (hDecoder->time_out[paired_channel] == NULL)
-    {
-        hDecoder->time_out[paired_channel] = (real_t*)faad_malloc(mul*hDecoder->frameLength*sizeof(real_t));
-        memset(hDecoder->time_out[paired_channel], 0, mul*hDecoder->frameLength*sizeof(real_t));
-    }
-
-    if (hDecoder->fb_intermed[channel] == NULL)
-    {
-        hDecoder->fb_intermed[channel] = (real_t*)faad_malloc(hDecoder->frameLength*sizeof(real_t));
-        memset(hDecoder->fb_intermed[channel], 0, hDecoder->frameLength*sizeof(real_t));
-    }
-    if (hDecoder->fb_intermed[paired_channel] == NULL)
-    {
-        hDecoder->fb_intermed[paired_channel] = (real_t*)faad_malloc(hDecoder->frameLength*sizeof(real_t));
-        memset(hDecoder->fb_intermed[paired_channel], 0, hDecoder->frameLength*sizeof(real_t));
-    }
-
-#ifdef SSR_DEC
-    if (hDecoder->object_type == SSR)
-    {
-        if (hDecoder->ssr_overlap[cpe->channel] == NULL)
-        {
-            hDecoder->ssr_overlap[cpe->channel] = (real_t*)faad_malloc(2*hDecoder->frameLength*sizeof(real_t));
-            memset(hDecoder->ssr_overlap[cpe->channel], 0, 2*hDecoder->frameLength*sizeof(real_t));
-        }
-        if (hDecoder->ssr_overlap[cpe->paired_channel] == NULL)
-        {
-            hDecoder->ssr_overlap[cpe->paired_channel] = (real_t*)faad_malloc(2*hDecoder->frameLength*sizeof(real_t));
-            memset(hDecoder->ssr_overlap[cpe->paired_channel], 0, 2*hDecoder->frameLength*sizeof(real_t));
-        }
-        if (hDecoder->prev_fmd[cpe->channel] == NULL)
-        {
-            uint16_t k;
-            hDecoder->prev_fmd[cpe->channel] = (real_t*)faad_malloc(2*hDecoder->frameLength*sizeof(real_t));
-            for (k = 0; k < 2*hDecoder->frameLength; k++)
-                hDecoder->prev_fmd[cpe->channel][k] = REAL_CONST(-1);
-        }
-        if (hDecoder->prev_fmd[cpe->paired_channel] == NULL)
-        {
-            uint16_t k;
-            hDecoder->prev_fmd[cpe->paired_channel] = (real_t*)faad_malloc(2*hDecoder->frameLength*sizeof(real_t));
-            for (k = 0; k < 2*hDecoder->frameLength; k++)
-                hDecoder->prev_fmd[cpe->paired_channel][k] = REAL_CONST(-1);
-        }
-    }
-#endif
-
-    return 0;
-}
-
-uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,
-                                   element *sce, int16_t *spec_data)
+uint8_t decode_single_channel(NeAACDecStruct *hDecoder, element *sce, real_t *spec_coef)
 {
     uint8_t retval;
-    uint8_t output_channels;
-    ALIGN real_t spec_coef[1024];
+    ic_stream *ics = &(sce->channels[0].ics);
+    int16_t *spec_data = sce->channels[0].spec_data;
+    uint8_t channel = sce->channel_index;

 #ifdef PROFILE
     int64_t count = faad_get_ts();
 #endif

-
-    /* always allocate 2 channels, PS can always "suddenly" turn up */
-#if ( (defined(DRM) && defined(DRM_PS)) )
-    output_channels = 2;
-#elif defined(PS_DEC)
-    if (hDecoder->ps_used[hDecoder->fr_ch_ele])
-        output_channels = 2;
-    else
-        output_channels = 1;
-#else
-    output_channels = 1;
-#endif
-
-    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)
-    {
-        /* element_output_channels not set yet */
-        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;
-    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {
-        /* element inconsistency */
-
-        /* this only happens if PS is actually found but not in the first frame
-         * this means that there is only 1 bitstream element!
-         */
-
-        /* The simplest way to fix the accounting,
-         * is to reallocate this and all the following channels.
-         */
-        memset(&hDecoder->element_alloced[hDecoder->fr_ch_ele], 0,
-            sizeof(uint8_t) * (MAX_SYNTAX_ELEMENTS - hDecoder->fr_ch_ele));
-
-        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;
-
-        //return 21;
-    }
-
-    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)
-    {
-        retval = allocate_single_channel(hDecoder, sce->channel, output_channels);
-        if (retval > 0)
-            return retval;
-
-        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 1;
-    }
-
-    /* sanity check, CVE-2018-20199, CVE-2018-20360 */
-    if(!hDecoder->time_out[sce->channel])
-        return 15;
-    if(output_channels > 1 && !hDecoder->time_out[sce->channel+1])
-        return 15;
-    if(!hDecoder->fb_intermed[sce->channel])
-        return 15;
-
     /* dequantisation and scaling */
     retval = quant_to_spec(hDecoder, ics, spec_data, spec_coef, hDecoder->frameLength);
     if (retval > 0)
@@ -975,7 +814,6 @@ uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,
     hDecoder->requant_cycles += count;
 #endif

-
     /* pns decoding */
     pns_decode(ics, NULL, spec_coef, NULL, hDecoder->frameLength, 0, hDecoder->object_type,
         &(hDecoder->__r1), &(hDecoder->__r2));
@@ -984,18 +822,18 @@ uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,
     /* MAIN object type prediction */
     if (hDecoder->object_type == MAIN)
     {
-		if (!hDecoder->pred_stat[sce->channel])
+		if (!hDecoder->pred_stat[channel])
 			return 33;

         /* intra channel prediction */
-        ic_prediction(ics, spec_coef, hDecoder->pred_stat[sce->channel], hDecoder->frameLength,
+        ic_prediction(ics, spec_coef, hDecoder->pred_stat[channel], hDecoder->frameLength,
             hDecoder->sf_index);

         /* In addition, for scalefactor bands coded by perceptual
            noise substitution the predictors belonging to the
            corresponding spectral coefficients are reset.
         */
-        pns_reset_pred_state(ics, hDecoder->pred_stat[sce->channel]);
+        pns_reset_pred_state(ics, hDecoder->pred_stat[channel]);
     }
 #endif

@@ -1008,15 +846,15 @@ uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,
             if (ics->ltp.data_present)
             {
                 if (ics->ltp.lag_update)
-                    hDecoder->ltp_lag[sce->channel] = ics->ltp.lag;
+                    hDecoder->ltp_lag[channel] = ics->ltp.lag;
             }
-            ics->ltp.lag = hDecoder->ltp_lag[sce->channel];
+            ics->ltp.lag = hDecoder->ltp_lag[channel];
         }
 #endif

         /* long term prediction */
-        lt_prediction(ics, &(ics->ltp), spec_coef, hDecoder->lt_pred_stat[sce->channel], hDecoder->fb,
-            ics->window_shape, hDecoder->window_shape_prev[sce->channel],
+        lt_prediction(ics, &(ics->ltp), spec_coef, hDecoder->lt_pred_stat[channel], hDecoder->fb,
+            ics->window_shape, hDecoder->window_shape_prev[channel],
             hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);
     }
 #endif
@@ -1029,134 +867,33 @@ uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,
 #ifdef APPLY_DRC
     if (hDecoder->drc->present)
     {
-        if (!hDecoder->drc->exclude_mask[sce->channel] || !hDecoder->drc->excluded_chns_present)
+        if (!hDecoder->drc->exclude_mask[channel] || !hDecoder->drc->excluded_chns_present)
             drc_decode(hDecoder->drc, spec_coef);
     }
 #endif
-    /* filter bank */
-#ifdef SSR_DEC
-    if (hDecoder->object_type != SSR)
-    {
-#endif
-        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,
-            hDecoder->window_shape_prev[sce->channel], spec_coef,
-            hDecoder->time_out[sce->channel], hDecoder->fb_intermed[sce->channel],
-            hDecoder->object_type, hDecoder->frameLength);
-#ifdef SSR_DEC
-    } else {
-        ssr_decode(&(ics->ssr), hDecoder->fb, ics->window_sequence, ics->window_shape,
-            hDecoder->window_shape_prev[sce->channel], spec_coef, hDecoder->time_out[sce->channel],
-            hDecoder->ssr_overlap[sce->channel], hDecoder->ipqf_buffer[sce->channel], hDecoder->prev_fmd[sce->channel],
-            hDecoder->frameLength);
-    }
-#endif
-
-    /* save window shape for next frame */
-    hDecoder->window_shape_prev[sce->channel] = ics->window_shape;
-
-#ifdef LTP_DEC
-    if (is_ltp_ot(hDecoder->object_type))
-    {
-        lt_update_state(hDecoder->lt_pred_stat[sce->channel], hDecoder->time_out[sce->channel],
-            hDecoder->fb_intermed[sce->channel], hDecoder->frameLength, hDecoder->object_type);
-    }
-#endif
-
-#ifdef SBR_DEC
-    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
-        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])
-    {
-        int ele = hDecoder->fr_ch_ele;
-        int ch = sce->channel;
-
-        /* following case can happen when forceUpSampling == 1 */
-        if (hDecoder->sbr[ele] == NULL)
-        {
-            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,
-                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),
-                hDecoder->downSampledSBR
-#ifdef DRM
-                , 0
-#endif
-                );
-        }
-        if (!hDecoder->sbr[ele])
-            return 19;
-
-        if (sce->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)
-            hDecoder->sbr[ele]->maxAACLine = 8*min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);
-        else
-            hDecoder->sbr[ele]->maxAACLine = min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);
-
-        /* check if any of the PS tools is used */
-#if (defined(PS_DEC) || defined(DRM_PS))
-        if (hDecoder->ps_used[ele] == 0)
-        {
-#endif
-            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],
-                hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);
-#if (defined(PS_DEC) || defined(DRM_PS))
-        } else {
-            retval = sbrDecodeSingleFramePS(hDecoder->sbr[ele], hDecoder->time_out[ch],
-                hDecoder->time_out[ch+1], hDecoder->postSeekResetFlag,
-                hDecoder->downSampledSBR);
-        }
-#endif
-        if (retval > 0)
-            return retval;
-    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
-        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])
-    {
-        return 23;
-    }
-#endif
-
-    /* copy L to R when no PS is used */
-#if (defined(PS_DEC) || defined(DRM_PS))
-    if ((hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&
-        (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))
-    {
-        int ele = hDecoder->fr_ch_ele;
-        int ch = sce->channel;
-        int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;
-        frame_size *= hDecoder->frameLength*sizeof(real_t);
-
-        memcpy(hDecoder->time_out[ch+1], hDecoder->time_out[ch], frame_size);
-    }
-#endif

     return 0;
 }

-uint8_t reconstruct_channel_pair(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_stream *ics2,
-                                 element *cpe, int16_t *spec_data1, int16_t *spec_data2)
+uint8_t decode_channel_pair(NeAACDecStruct *hDecoder, element *cpe, real_t *spec_coef1, real_t *spec_coef2)
 {
     uint8_t retval;
-    ALIGN real_t spec_coef1[1024];
-    ALIGN real_t spec_coef2[1024];
+    ic_stream *ics1 = &(cpe->channels[0].ics);
+    ic_stream *ics2 = &(cpe->channels[1].ics);
+    int16_t *spec_data1 = cpe->channels[0].spec_data;
+    int16_t *spec_data2 = cpe->channels[1].spec_data;
+    uint8_t channel = cpe->channel_index;
+    uint8_t paired_channel = channel + 1;

 #ifdef PROFILE
     int64_t count = faad_get_ts();
 #endif
-    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] != 2)
-    {
-        retval = allocate_channel_pair(hDecoder, cpe->channel, (uint8_t)cpe->paired_channel);
-        if (retval > 0)
-            return retval;
-
-        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 2;
-    }
-
-    /* sanity check, CVE-2018-20199, CVE-2018-20360 */
-    if(!hDecoder->time_out[cpe->channel] || !hDecoder->time_out[cpe->paired_channel])
-        return 15;
-    if(!hDecoder->fb_intermed[cpe->channel] || !hDecoder->fb_intermed[cpe->paired_channel])
-        return 15;

     /* dequantisation and scaling */
     retval = quant_to_spec(hDecoder, ics1, spec_data1, spec_coef1, hDecoder->frameLength);
     if (retval > 0)
         return retval;
+
     retval = quant_to_spec(hDecoder, ics2, spec_data2, spec_coef2, hDecoder->frameLength);
     if (retval > 0)
         return retval;
@@ -1219,17 +956,17 @@ uint8_t reconstruct_channel_pair(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_s
     if (hDecoder->object_type == MAIN)
     {
         /* intra channel prediction */
-        ic_prediction(ics1, spec_coef1, hDecoder->pred_stat[cpe->channel], hDecoder->frameLength,
+        ic_prediction(ics1, spec_coef1, hDecoder->pred_stat[channel], hDecoder->frameLength,
             hDecoder->sf_index);
-        ic_prediction(ics2, spec_coef2, hDecoder->pred_stat[cpe->paired_channel], hDecoder->frameLength,
+        ic_prediction(ics2, spec_coef2, hDecoder->pred_stat[paired_channel], hDecoder->frameLength,
             hDecoder->sf_index);

         /* In addition, for scalefactor bands coded by perceptual
            noise substitution the predictors belonging to the
            corresponding spectral coefficients are reset.
         */
-        pns_reset_pred_state(ics1, hDecoder->pred_stat[cpe->channel]);
-        pns_reset_pred_state(ics2, hDecoder->pred_stat[cpe->paired_channel]);
+        pns_reset_pred_state(ics1, hDecoder->pred_stat[channel]);
+        pns_reset_pred_state(ics2, hDecoder->pred_stat[paired_channel]);
     }
 #endif

@@ -1244,24 +981,24 @@ uint8_t reconstruct_channel_pair(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_s
             if (ltp1->data_present)
             {
                 if (ltp1->lag_update)
-                    hDecoder->ltp_lag[cpe->channel] = ltp1->lag;
+                    hDecoder->ltp_lag[channel] = ltp1->lag;
             }
-            ltp1->lag = hDecoder->ltp_lag[cpe->channel];
+            ltp1->lag = hDecoder->ltp_lag[channel];
             if (ltp2->data_present)
             {
                 if (ltp2->lag_update)
-                    hDecoder->ltp_lag[cpe->paired_channel] = ltp2->lag;
+                    hDecoder->ltp_lag[paired_channel] = ltp2->lag;
             }
-            ltp2->lag = hDecoder->ltp_lag[cpe->paired_channel];
+            ltp2->lag = hDecoder->ltp_lag[paired_channel];
         }
 #endif

         /* long term prediction */
-        lt_prediction(ics1, ltp1, spec_coef1, hDecoder->lt_pred_stat[cpe->channel], hDecoder->fb,
-            ics1->window_shape, hDecoder->window_shape_prev[cpe->channel],
+        lt_prediction(ics1, ltp1, spec_coef1, hDecoder->lt_pred_stat[channel], hDecoder->fb,
+            ics1->window_shape, hDecoder->window_shape_prev[channel],
             hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);
-        lt_prediction(ics2, ltp2, spec_coef2, hDecoder->lt_pred_stat[cpe->paired_channel], hDecoder->fb,
-            ics2->window_shape, hDecoder->window_shape_prev[cpe->paired_channel],
+        lt_prediction(ics2, ltp2, spec_coef2, hDecoder->lt_pred_stat[paired_channel], hDecoder->fb,
+            ics2->window_shape, hDecoder->window_shape_prev[paired_channel],
             hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);
     }
 #endif
@@ -1276,49 +1013,250 @@ uint8_t reconstruct_channel_pair(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_s
 #if APPLY_DRC
     if (hDecoder->drc->present)
     {
-        if (!hDecoder->drc->exclude_mask[cpe->channel] || !hDecoder->drc->excluded_chns_present)
+        if (!hDecoder->drc->exclude_mask[channel] || !hDecoder->drc->excluded_chns_present)
             drc_decode(hDecoder->drc, spec_coef1);
-        if (!hDecoder->drc->exclude_mask[cpe->paired_channel] || !hDecoder->drc->excluded_chns_present)
+        if (!hDecoder->drc->exclude_mask[paired_channel] || !hDecoder->drc->excluded_chns_present)
             drc_decode(hDecoder->drc, spec_coef2);
     }
 #endif
-    /* filter bank */
-#ifdef SSR_DEC
-    if (hDecoder->object_type != SSR)
-    {
-#endif
-        ifilter_bank(hDecoder->fb, ics1->window_sequence, ics1->window_shape,
-            hDecoder->window_shape_prev[cpe->channel], spec_coef1,
-            hDecoder->time_out[cpe->channel], hDecoder->fb_intermed[cpe->channel],
-            hDecoder->object_type, hDecoder->frameLength);
-        ifilter_bank(hDecoder->fb, ics2->window_sequence, ics2->window_shape,
-            hDecoder->window_shape_prev[cpe->paired_channel], spec_coef2,
-            hDecoder->time_out[cpe->paired_channel], hDecoder->fb_intermed[cpe->paired_channel],
+
+    return 0;
+}
+
+uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, element *sce)
+{
+    uint8_t retval;
+    uint8_t output_channels;
+    ic_stream *ics = &(sce->channels[0].ics);
+    ALIGN real_t spec_coef[1024];
+    unsigned int ch = sce->channel_index;
+
+    /* always allocate 2 channels, PS can always "suddenly" turn up */
+#if ( (defined(DRM) && defined(DRM_PS)) )
+    output_channels = 2;
+#elif defined(PS_DEC)
+    if (hDecoder->ps_used[hDecoder->fr_ch_ele])
+        output_channels = 2;
+    else
+        output_channels = 1;
+#else
+    output_channels = 1;
+#endif
+
+    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)
+    {
+        /* element_output_channels not set yet */
+        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;
+    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {
+        /* element inconsistency */
+
+        /* this only happens if PS is actually found but not in the first frame
+         * this means that there is only 1 bitstream element!
+         */
+
+        /* The simplest way to fix the accounting,
+         * is to reallocate this and all the following channels.
+         */
+        memset(&hDecoder->element_alloced[hDecoder->fr_ch_ele], 0,
+            sizeof(uint8_t) * (MAX_SYNTAX_ELEMENTS - hDecoder->fr_ch_ele));
+
+        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;
+
+        //return 21;
+    }
+
+    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)
+    {
+        retval = allocate_single_channel(hDecoder, ch);
+        if (retval > 0)
+            return retval;
+
+        if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)
+        {
+            retval = allocate_time_channel(hDecoder, ch+1);
+            if (retval > 0)
+                return retval;
+        }
+
+        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 1;
+    }
+
+    /* sanity check, CVE-2018-20199, CVE-2018-20360 */
+    if(!hDecoder->time_out[ch])
+        return 15;
+    if(output_channels > 1 && !hDecoder->time_out[ch+1])
+        return 15;
+    if(!hDecoder->fb_intermed[ch])
+        return 15;
+
+    retval = decode_single_channel(hDecoder, sce, spec_coef);
+    if (retval > 0)
+        return retval;
+
+    /* filter bank */
+#ifdef SSR_DEC
+    if (hDecoder->object_type != SSR)
+    {
+#endif
+        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,
+            hDecoder->window_shape_prev[ch], spec_coef,
+            hDecoder->time_out[ch], hDecoder->fb_intermed[ch],
+            hDecoder->object_type, hDecoder->frameLength);
+#ifdef SSR_DEC
+    } else {
+        ssr_decode(&(ics->ssr), hDecoder->fb, ics->window_sequence, ics->window_shape,
+            hDecoder->window_shape_prev[ch], spec_coef, hDecoder->time_out[ch],
+            hDecoder->ssr_overlap[ch], hDecoder->ipqf_buffer[ch], hDecoder->prev_fmd[ch],
+            hDecoder->frameLength);
+    }
+#endif
+
+    /* save window shape for next frame */
+    hDecoder->window_shape_prev[ch] = ics->window_shape;
+
+#ifdef LTP_DEC
+    if (is_ltp_ot(hDecoder->object_type))
+    {
+        lt_update_state(hDecoder->lt_pred_stat[ch], hDecoder->time_out[ch],
+            hDecoder->fb_intermed[ch], hDecoder->frameLength, hDecoder->object_type);
+    }
+#endif
+
+#ifdef SBR_DEC
+    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
+        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])
+    {
+        int ele = hDecoder->fr_ch_ele;
+
+        /* following case can happen when forceUpSampling == 1 */
+        if (hDecoder->sbr[ele] == NULL)
+        {
+            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,
+                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),
+                hDecoder->downSampledSBR
+#ifdef DRM
+                , 0
+#endif
+                );
+        }
+        if (!hDecoder->sbr[ele])
+            return 19;
+
+        if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)
+            hDecoder->sbr[ele]->maxAACLine = 8*min(ics->swb_offset[max(ics->max_sfb-1, 0)], ics->swb_offset_max);
+        else
+            hDecoder->sbr[ele]->maxAACLine = min(ics->swb_offset[max(ics->max_sfb-1, 0)], ics->swb_offset_max);
+
+        real_t* chan[2];
+        chan[0] = hDecoder->time_out[ch];
+        chan[1] = hDecoder->time_out[ch+1];
+        int ps_used = 0;
+
+#if (defined(PS_DEC) || defined(DRM_PS))
+        ps_used = hDecoder->ps_used[ele] != 0;
+#endif
+
+        retval = sbrDecodeFrames(hDecoder->sbr[ele],
+            1, chan,
+            hDecoder->postSeekResetFlag, hDecoder->downSampledSBR, ps_used);
+        if (retval > 0)
+            return retval;
+    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
+        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])
+    {
+        return 23;
+    }
+#endif
+
+    /* copy L to R when no PS is used */
+#if (defined(PS_DEC) || defined(DRM_PS))
+    if ((hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&
+        (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))
+    {
+        int ele = hDecoder->fr_ch_ele;
+        int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;
+        frame_size *= hDecoder->frameLength*sizeof(real_t);
+
+        memcpy(hDecoder->time_out[ch+1], hDecoder->time_out[ch], frame_size);
+    }
+#endif
+
+    return 0;
+}
+
+uint8_t reconstruct_channel_pair(NeAACDecStruct *hDecoder, element *cpe)
+{
+    uint8_t retval;
+    ic_stream *ics1 = &(cpe->channels[0].ics);
+    ic_stream *ics2 = &(cpe->channels[1].ics);
+    ALIGN real_t spec_coef1[1024];
+    ALIGN real_t spec_coef2[1024];
+    uint8_t channel = cpe->channel_index;
+    uint8_t paired_channel = cpe->channel_index+1;
+
+#ifdef PROFILE
+    int64_t count = faad_get_ts();
+#endif
+    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] != 2)
+    {
+        retval = allocate_single_channel(hDecoder, channel);
+        if (retval > 0)
+            return retval;
+
+        retval = allocate_single_channel(hDecoder, (uint8_t)paired_channel);
+        if (retval > 0)
+            return retval;
+
+        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 2;
+    }
+
+    /* sanity check, CVE-2018-20199, CVE-2018-20360 */
+    if(!hDecoder->time_out[channel] || !hDecoder->time_out[paired_channel])
+        return 15;
+    if(!hDecoder->fb_intermed[channel] || !hDecoder->fb_intermed[paired_channel])
+        return 15;
+
+    retval = decode_channel_pair(hDecoder, cpe, spec_coef1, spec_coef2);
+    if (retval > 0)
+        return retval;
+
+    /* filter bank */
+#ifdef SSR_DEC
+    if (hDecoder->object_type != SSR)
+    {
+#endif
+        ifilter_bank(hDecoder->fb, ics1->window_sequence, ics1->window_shape,
+            hDecoder->window_shape_prev[channel], spec_coef1,
+            hDecoder->time_out[channel], hDecoder->fb_intermed[channel],
+            hDecoder->object_type, hDecoder->frameLength);
+        ifilter_bank(hDecoder->fb, ics2->window_sequence, ics2->window_shape,
+            hDecoder->window_shape_prev[paired_channel], spec_coef2,
+            hDecoder->time_out[paired_channel], hDecoder->fb_intermed[paired_channel],
             hDecoder->object_type, hDecoder->frameLength);
 #ifdef SSR_DEC
     } else {
         ssr_decode(&(ics1->ssr), hDecoder->fb, ics1->window_sequence, ics1->window_shape,
-            hDecoder->window_shape_prev[cpe->channel], spec_coef1, hDecoder->time_out[cpe->channel],
-            hDecoder->ssr_overlap[cpe->channel], hDecoder->ipqf_buffer[cpe->channel],
-            hDecoder->prev_fmd[cpe->channel], hDecoder->frameLength);
+            hDecoder->window_shape_prev[channel], spec_coef1, hDecoder->time_out[channel],
+            hDecoder->ssr_overlap[channel], hDecoder->ipqf_buffer[channel],
+            hDecoder->prev_fmd[channel], hDecoder->frameLength);
         ssr_decode(&(ics2->ssr), hDecoder->fb, ics2->window_sequence, ics2->window_shape,
-            hDecoder->window_shape_prev[cpe->paired_channel], spec_coef2, hDecoder->time_out[cpe->paired_channel],
-            hDecoder->ssr_overlap[cpe->paired_channel], hDecoder->ipqf_buffer[cpe->paired_channel],
-            hDecoder->prev_fmd[cpe->paired_channel], hDecoder->frameLength);
+            hDecoder->window_shape_prev[paired_channel], spec_coef2, hDecoder->time_out[paired_channel],
+            hDecoder->ssr_overlap[paired_channel], hDecoder->ipqf_buffer[paired_channel],
+            hDecoder->prev_fmd[paired_channel], hDecoder->frameLength);
     }
 #endif

     /* save window shape for next frame */
-    hDecoder->window_shape_prev[cpe->channel] = ics1->window_shape;
-    hDecoder->window_shape_prev[cpe->paired_channel] = ics2->window_shape;
+    hDecoder->window_shape_prev[channel] = ics1->window_shape;
+    hDecoder->window_shape_prev[paired_channel] = ics2->window_shape;

 #ifdef LTP_DEC
     if (is_ltp_ot(hDecoder->object_type))
     {
-        lt_update_state(hDecoder->lt_pred_stat[cpe->channel], hDecoder->time_out[cpe->channel],
-            hDecoder->fb_intermed[cpe->channel], hDecoder->frameLength, hDecoder->object_type);
-        lt_update_state(hDecoder->lt_pred_stat[cpe->paired_channel], hDecoder->time_out[cpe->paired_channel],
-            hDecoder->fb_intermed[cpe->paired_channel], hDecoder->frameLength, hDecoder->object_type);
+        lt_update_state(hDecoder->lt_pred_stat[channel], hDecoder->time_out[channel],
+            hDecoder->fb_intermed[channel], hDecoder->frameLength, hDecoder->object_type);
+        lt_update_state(hDecoder->lt_pred_stat[paired_channel], hDecoder->time_out[paired_channel],
+            hDecoder->fb_intermed[paired_channel], hDecoder->frameLength, hDecoder->object_type);
     }
 #endif

@@ -1327,8 +1265,195 @@ uint8_t reconstruct_channel_pair(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_s
         && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])
     {
         int ele = hDecoder->fr_ch_ele;
-        int ch0 = cpe->channel;
-        int ch1 = cpe->paired_channel;
+        int ch0 = channel;
+        int ch1 = paired_channel;
+
+        /* following case can happen when forceUpSampling == 1 */
+        if (hDecoder->sbr[ele] == NULL)
+        {
+            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,
+                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),
+                hDecoder->downSampledSBR
+#ifdef DRM
+                , 0
+#endif
+                );
+        }
+        if (!hDecoder->sbr[ele])
+            return 19;
+
+        if (ics1->window_sequence == EIGHT_SHORT_SEQUENCE)
+            hDecoder->sbr[ele]->maxAACLine = 8*min(ics1->swb_offset[max(ics1->max_sfb-1, 0)], ics1->swb_offset_max);
+        else
+            hDecoder->sbr[ele]->maxAACLine = min(ics1->swb_offset[max(ics1->max_sfb-1, 0)], ics1->swb_offset_max);
+
+        real_t* chan[2];
+        chan[0] = hDecoder->time_out[ch0];
+
+        if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 2)
+            chan[1] = hDecoder->time_out[ch1];
+
+        retval = sbrDecodeFrames(hDecoder->sbr[ele],
+            2, chan,
+            hDecoder->postSeekResetFlag, hDecoder->downSampledSBR, 0);
+        if (retval > 0)
+            return retval;
+    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
+        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])
+    {
+        return 23;
+    }
+#endif
+
+    return 0;
+}
+
+uint8_t reconstruct_scaled_channel(NeAACDecStruct *hDecoder, element *base, element *enh)
+{
+    uint8_t retval;
+    ic_stream *ics1 = &(base->channels[0].ics);
+    ic_stream *ics2 = &(base->channels[0].ics);
+    ALIGN real_t spec_coef[2][1204];
+
+    const unsigned int ch0 = base->channel_index;
+    const unsigned int ch1 = ch0 + 1;
+    unsigned int max_channels = base->num_channels;
+
+    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] != 2)
+    {
+        retval = allocate_single_channel(hDecoder, ch0);
+        if (retval > 0)
+            return retval;
+
+        retval = allocate_single_channel(hDecoder, (uint8_t)ch1);
+        if (retval > 0)
+            return retval;
+
+        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 2;
+    }
+
+    /* sanity check, CVE-2018-20199, CVE-2018-20360 */
+    if(!hDecoder->time_out[ch0] || !hDecoder->time_out[ch1])
+        return 15;
+    if(!hDecoder->fb_intermed[ch0] || !hDecoder->fb_intermed[ch1])
+        return 15;
+
+    for (int i = 0; i < base->num_channels; i++)
+    {
+        ic_stream *ics = &(base->channels[i].ics);
+
+        /* dequantisation and scaling */
+        retval = quant_to_spec(hDecoder, ics, base->channels[i].spec_data,
+            spec_coef[i], hDecoder->frameLength);
+        if (retval > 0)
+            return retval;
+    }
+
+    if (enh)
+    {
+        if (max_channels < enh->num_channels)
+            max_channels = enh->num_channels;
+
+        ALIGN real_t spec_enh[2][1024]  = {0};
+
+        for (int i = 0; i < enh->num_channels; i++)
+        {
+            ic_stream *ics = &(enh->channels[i].ics);
+
+            /* dequantisation and scaling */
+            retval = quant_to_spec(hDecoder, ics, enh->channels[i].spec_data,
+                spec_enh[i], hDecoder->frameLength);
+            if (retval > 0)
+                return retval;
+        }
+
+        if (base->num_channels == 1)
+        {
+            for (int i = 0; i < hDecoder->frameLength; i++)
+            {
+                for (int j = 0; j < enh->num_channels; j++)
+                {
+                    spec_coef[0][i] = spec_coef[0][i] + spec_enh[j][i];
+                }
+            }
+        }
+        else
+        {
+            for (int i = 0; i < hDecoder->frameLength; i++)
+            {
+                for (int j = 0; j < enh->num_channels; j++)
+                {
+                    spec_coef[0][i] = spec_coef[j][i] + spec_enh[j][i];
+                }
+            }
+        }
+    }
+
+    if (max_channels == 2)
+    {
+        /* pns decoding */
+        if (ics1->ms_mask_present)
+        {
+            pns_decode(ics1, ics2, spec_coef[0], spec_coef[1], hDecoder->frameLength, 1, hDecoder->object_type,
+                &(hDecoder->__r1), &(hDecoder->__r2));
+        } else {
+            pns_decode(ics1, ics2, spec_coef[0], spec_coef[1], hDecoder->frameLength, 0, hDecoder->object_type,
+                &(hDecoder->__r1), &(hDecoder->__r2));
+        }
+
+        /* mid/side decoding */
+        ms_decode(ics1, ics2, spec_coef[0], spec_coef[1], hDecoder->frameLength);
+
+        /* intensity stereo decoding */
+        is_decode(ics1, ics2, spec_coef[0], spec_coef[1], hDecoder->frameLength);
+    }
+    else
+    {
+        /* pns decoding */
+        pns_decode(ics1, NULL, spec_coef[0],
+            NULL, hDecoder->frameLength, 0, hDecoder->object_type,
+            &(hDecoder->__r1), &(hDecoder->__r2));
+    }
+
+    for (int i = 0; i < max_channels; i++)
+    {
+        /* tns decoding */
+        tns_decode_frame(ics1, &(ics1->tns), hDecoder->sf_index, hDecoder->object_type,
+            spec_coef[i], hDecoder->frameLength);
+    }
+
+    /* drc decoding */
+#if APPLY_DRC
+    if (hDecoder->drc->present)
+    {
+        for (int i = 0; i < max_channels; i++)
+        {
+            if (!hDecoder->drc->exclude_mask[i] || !hDecoder->drc->excluded_chns_present)
+                drc_decode(hDecoder->drc, spec_coef[i]);
+        }
+    }
+#endif
+
+    /* filter bank */
+    for (int i = 0; i < max_channels; i++)
+    {
+        const int ch = base->channel_index + i;
+        const ic_stream* ics = &base->channels[i].ics;
+
+        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,
+            hDecoder->window_shape_prev[ch], spec_coef[i],
+            hDecoder->time_out[ch], hDecoder->fb_intermed[ch],
+            hDecoder->object_type, hDecoder->frameLength);
+
+        /* save window shape for next frame */
+        hDecoder->window_shape_prev[ch] = ics->window_shape;
+    }
+
+#ifdef SBR_DEC
+    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
+        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])
+    {
+        const int ele = hDecoder->fr_ch_ele;

         /* following case can happen when forceUpSampling == 1 */
         if (hDecoder->sbr[ele] == NULL)
@@ -1344,14 +1469,26 @@ uint8_t reconstruct_channel_pair(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_s
         if (!hDecoder->sbr[ele])
             return 19;

-        if (cpe->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)
-            hDecoder->sbr[ele]->maxAACLine = 8*min(cpe->ics1.swb_offset[max(cpe->ics1.max_sfb-1, 0)], cpe->ics1.swb_offset_max);
+        if (ics1->window_sequence == EIGHT_SHORT_SEQUENCE)
+            hDecoder->sbr[ele]->maxAACLine = 8*min(ics1->swb_offset[max(ics1->max_sfb-1, 0)], ics1->swb_offset_max);
         else
-            hDecoder->sbr[ele]->maxAACLine = min(cpe->ics1.swb_offset[max(cpe->ics1.max_sfb-1, 0)], cpe->ics1.swb_offset_max);
+            hDecoder->sbr[ele]->maxAACLine = min(ics1->swb_offset[max(ics1->max_sfb-1, 0)], ics1->swb_offset_max);

-        retval = sbrDecodeCoupleFrame(hDecoder->sbr[ele],
-            hDecoder->time_out[ch0], hDecoder->time_out[ch1],
-            hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);
+        real_t* time_outs[2];
+        time_outs[0] = hDecoder->time_out[ch0];
+        time_outs[1] = hDecoder->time_out[ch1];
+        int ps_used = 0;
+
+        if (base->num_channels == 1)
+        {
+#if (defined(PS_DEC) || defined(DRM_PS))
+            ps_used = hDecoder->ps_used[ele] != 0;
+#endif
+        }
+
+        retval = sbrDecodeFrames(hDecoder->sbr[ele],
+            base->num_channels, time_outs,
+        hDecoder->postSeekResetFlag, hDecoder->downSampledSBR, ps_used);
         if (retval > 0)
             return retval;
     } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
@@ -1361,5 +1498,19 @@ uint8_t reconstruct_channel_pair(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_s
     }
 #endif

+    /* copy L to R when no PS is used */
+#if (defined(PS_DEC) || defined(DRM_PS))
+    if (max_channels == 1 && (hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&
+        (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))
+    {
+        int ele = hDecoder->fr_ch_ele;
+        int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;
+        frame_size *= hDecoder->frameLength*sizeof(real_t);
+
+        memcpy(hDecoder->time_out[ch1], hDecoder->time_out[ch0], frame_size);
+    }
+#endif
+
+
     return 0;
 }
diff --git a/libfaad/specrec.h b/libfaad/specrec.h
index 8464ca9..9235a7a 100644
--- a/libfaad/specrec.h
+++ b/libfaad/specrec.h
@@ -38,10 +38,9 @@ extern "C" {
 #include "syntax.h"

 uint8_t window_grouping_info(NeAACDecStruct *hDecoder, ic_stream *ics);
-uint8_t reconstruct_channel_pair(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_stream *ics2,
-                                 element *cpe, int16_t *spec_data1, int16_t *spec_data2);
-uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics, element *sce,
-                                int16_t *spec_data);
+uint8_t reconstruct_channel_pair(NeAACDecStruct *hDecoder, element *cpe);
+uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, element *sce);
+uint8_t reconstruct_scaled_channel(NeAACDecStruct *hDecoder, element *base, element *enh);

 #ifdef __cplusplus
 }
diff --git a/libfaad/structs.h b/libfaad/structs.h
index 3abc888..6f8fecd 100644
--- a/libfaad/structs.h
+++ b/libfaad/structs.h
@@ -302,14 +302,19 @@ typedef struct

 typedef struct
 {
-    uint8_t channel;
-    int16_t paired_channel;
+    ic_stream ics;
+    ALIGN int16_t spec_data[1024];
+} channel_element;
+
+typedef struct
+{
+    uint8_t num_channels;
+    uint8_t channel_index;

     uint8_t element_instance_tag;
     uint8_t common_window;

-    ic_stream ics1;
-    ic_stream ics2;
+    channel_element channels[2];
 } element; /* syntax element (SCE, CPE, LFE) */

 #define MAX_ASC_BYTES 64
diff --git a/libfaad/syntax.c b/libfaad/syntax.c
index 56ae310..775b9e6 100644
--- a/libfaad/syntax.c
+++ b/libfaad/syntax.c
@@ -86,7 +86,7 @@ static void gain_control_data(bitfile *ld, ic_stream *ics);
 static uint8_t spectral_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,
                              int16_t *spectral_data);
 static uint8_t pulse_data(ic_stream *ics, pulse_info *pul, bitfile *ld);
-static void tns_data(ic_stream *ics, tns_info *tns, bitfile *ld);
+static void tns_data(NeAACDecStruct *hDecoder, ic_stream *ics, tns_info *tns, bitfile *ld);
 #ifdef LTP_DEC
 static uint8_t ltp_data(NeAACDecStruct *hDecoder, ic_stream *ics, ltp_info *ltp, bitfile *ld);
 #endif
@@ -446,6 +446,441 @@ static void decode_cpe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfi
     hDecoder->fr_ch_ele++;
 }

+#ifdef HDC
+
+static int hdc_data_frame(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_stream *ics2, bitfile *ld,
+    int layer_stereo, int last_max_sfb_ms, int enh)
+{
+    uint8_t retval = 0;
+    uint8_t ics_reserved_bit;
+
+    ics_reserved_bit = faad_get1bit(ld
+                DEBUGVAR(1,43,"hdc_data_frame(): ics_reserved_bit"));
+    if (ics_reserved_bit != 0)
+        return 32;
+
+    if (!enh)
+    {
+        ics1->window_shape = faad_get1bit(ld
+               DEBUGVAR(1,45,"hdc_data_frame(): window_shape"));
+        ics1->window_sequence = (uint8_t)faad_getbits(ld, 2
+            DEBUGVAR(1,44,"hdc_data_frame(): window_sequence"));
+    }
+
+    if (ics1->window_sequence == EIGHT_SHORT_SEQUENCE)
+    {
+        ics1->max_sfb = (uint8_t)faad_getbits(ld, 4
+            DEBUGVAR(1,46,"hdc_data_frame(): max_sfb (short)"));
+
+        if (!enh)
+        {
+            ics1->scale_factor_grouping = (uint8_t)faad_getbits(ld, 7
+                 DEBUGVAR(1,47,"hdc_data_frame(): scale_factor_grouping"));
+        }
+    } else {
+        ics1->max_sfb = (uint8_t)faad_getbits(ld, 6
+            DEBUGVAR(1,48,"hdc_data_frame(): max_sfb (long)"));
+    }
+
+    //printf("enh: %d ics1->max_sfb: %d\n", enh, ics1->max_sfb);
+
+    /* get the grouping information */
+    if ((retval = window_grouping_info(hDecoder, ics1)) > 0)
+    {
+        printf("window_grouping_info. returned %d\n", retval);
+        return retval;
+    }
+
+    /* should be an error */
+    /* check the range of max_sfb */
+    if (ics1->max_sfb > ics1->num_swb)
+        return 16;
+
+    if (layer_stereo)
+    {
+        ics1->ms_mask_present = (uint8_t)faad_getbits(ld, 2
+           DEBUGVAR(1,306,"hdc_data_frame(): ms_mask_present"));
+        if (ics1->ms_mask_present == 3)
+        {
+            /* bitstream error */
+            printf("bitstream error ms_mask is equal to 3.\n");
+            return 32;
+        }
+        //if (enh)
+        //    printf("ics1->ms_mask_present %d last_max_sfb_ms: %d \n", ics1->ms_mask_present, last_max_sfb_ms);
+        if (ics1->ms_mask_present == 1)
+        {
+            uint8_t g, sfb;
+            for (g = 0; g < ics1->num_window_groups; g++)
+            {
+                for (sfb = last_max_sfb_ms; sfb < ics1->max_sfb; sfb++)
+                {
+                    ics1->ms_used[g][sfb] = faad_get1bit(ld
+                        DEBUGVAR(1,307,"hdc_data_frame(): faad_get1bit"));
+
+                    //if (enh)
+                    //    printf("ms_used: %d\n", ics1->ms_used[g][sfb]);
+                }
+            }
+        }
+        memcpy(ics2, ics1, sizeof(ic_stream));
+    }
+    else
+    {
+        ics1->ms_mask_present = 0;
+    }
+
+    return 0;
+}
+
+static uint8_t hdc_sbr_data_block(NeAACDecStruct *hDecoder, bitfile *ld)
+{
+    uint16_t count;
+    uint32_t bitsconsumed = faad_get_processed_bits(ld);
+    uint32_t buffer_size = faad_origbitbuffer_size(ld);
+
+    if (bitsconsumed > buffer_size*8)
+    {
+        return 14;
+    }
+
+    if (!hDecoder->sbr[0])
+    {
+        hDecoder->sbr[0] = sbrDecodeInit(hDecoder->frameLength,
+            hDecoder->element_id[0], 2*get_sample_rate(hDecoder->sf_index),
+            hDecoder->downSampledSBR
+#ifdef DRM
+            , 0
+#endif
+
+            );
+    }
+    hDecoder->sbr[0]->Is_HDC_SBR = 1;
+
+    count = (uint16_t)bit2byte(buffer_size*8 - bitsconsumed);
+
+    hDecoder->sbr[0]->ret = sbr_extension_data(ld, hDecoder->sbr[0], count, hDecoder->postSeekResetFlag);
+#if (defined(PS_DEC) || defined(DRM_PS))
+    if (hDecoder->sbr[0]->ps_used)
+    {
+        hDecoder->ps_used[0] = 1;
+        hDecoder->ps_used_global = 1;
+    }
+#endif
+    return 0;
+}
+
+static int hdc_is_stereo_layer(const int block_type)
+{
+    switch (block_type)
+    {
+    case 0:
+    case 1:
+            return 0;
+    case 2:
+            return 1;
+    case 5:
+    case 6:
+            return 0;
+    case 7:
+            return 1;
+    default:
+        {
+            fprintf(stderr, "Unknown HDC block type: %d\n", block_type);
+            return 0;
+        }
+    }
+}
+
+static int hdc_enhanced_is_stereo_layer(const int block_type)
+{
+    switch (block_type)
+    {
+    case 0:
+    case 1:
+        return 0;
+    case 2:
+        return 1;
+    case 5:
+        return 0;
+    case 6:
+        return 1;
+    case 7:
+        return 1;
+    default:
+        {
+            fprintf(stderr, "Unknown HDC enhanced block type: %d\n", block_type);
+            return 0;
+        }
+    }
+}
+
+static uint8_t hdc_enhanced_stream(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,
+                                   element* cpe, bitfile *ld, int layer_stereo,
+                                   int mono_stereo_flag, int mono_layer_flag)
+{
+    uint8_t result;
+    ic_stream *ics1 = &(cpe->channels[0].ics);
+    ic_stream *ics2 = &(cpe->channels[1].ics);
+    int16_t* spec_data1 = cpe->channels[0].spec_data;
+    int16_t* spec_data2 = cpe->channels[1].spec_data;
+    uint8_t channels = 0;
+
+    if (layer_stereo)
+    {
+        hDecoder->element_id[hDecoder->fr_ch_ele] = ID_CPE;
+    }
+    else
+    {
+        hDecoder->element_id[hDecoder->fr_ch_ele] = ID_SCE;
+    }
+
+    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)
+        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;
+
+    const int last_max_sfb = ics1->max_sfb;
+    const int last_max_sfb_ms = mono_stereo_flag ? 0 : last_max_sfb;
+
+    result = hdc_data_frame(hDecoder, ics1, ics2, ld, 1, last_max_sfb_ms, 1);
+    if (result > 0)
+    {
+        printf("failed at hdc_data_frame %d\n", result);
+        return result;
+    }
+
+    cpe->common_window = 1;
+    cpe->channel_index = channels;
+    cpe->num_channels = 1;
+
+    if (layer_stereo)
+    {
+        cpe->num_channels++;
+    }
+
+    ics1->tns_data_present = faad_get1bit(ld);
+    if (ics1->tns_data_present)
+        tns_data(hDecoder, ics1, &(ics1->tns), ld);
+    /* get tns data */
+    if ((ics2->tns_data_present = faad_get1bit(ld)) & 1)
+        tns_data(hDecoder, ics2, &(ics2->tns), ld);
+
+    if (mono_layer_flag && layer_stereo)
+    {
+        for (int i = 0; i < 2; i++)
+        {
+            if (ics1->window_sequence != EIGHT_SHORT_SEQUENCE)
+            {
+                uint8_t sfb;
+                uint8_t limit = min(ics1->max_sfb, last_max_sfb);
+
+                for (sfb = last_max_sfb_ms; sfb < limit; sfb++)
+                {
+                    if (!(ics1->ms_used[0][sfb] || ics1->ms_mask_present == 2))
+                    {
+                        faad_get1bit(ld DEBUGVAR(1,55,"hdc_stream(): control bits"));
+                    }
+                }
+            }
+            else
+            {
+                uint8_t win;
+
+                for(win=0; win < 8; win++)
+                {
+                    faad_get1bit(ld DEBUGVAR(1,55,"hdc_stream(): control bits"));
+                }
+            }
+        }
+    }
+
+    result = side_info(hDecoder, cpe, ld, ics1, 1);
+    if (result > 0)
+    {
+        printf("side_info %d\n", result);
+        return result;
+    }
+
+    /* decode the spectral data */
+    if ((result = spectral_data(hDecoder, ics1, ld, spec_data1)) > 0)
+    {
+        printf("spectral_data %d\n", result);
+        return result;
+    }
+    if (layer_stereo)
+    {
+        result = side_info(hDecoder, cpe, ld, ics2, 1);
+        if (result > 0)
+        {
+            printf("side_info 2nd %d\n", result);
+            return result;
+        }
+
+        if ((result = spectral_data(hDecoder, ics2, ld, spec_data2)) > 0)
+            return result;
+    }
+    return 0;
+}
+
+static uint8_t hdc_stream(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,
+                          element* cpe, bitfile *ld, int layer_stereo)
+{
+    uint8_t result;
+    ic_stream *ics1 = &(cpe->channels[0].ics);
+    ic_stream *ics2 = &(cpe->channels[1].ics);
+    int16_t* spec_data1 = cpe->channels[0].spec_data;
+    int16_t* spec_data2 = cpe->channels[1].spec_data;
+    uint8_t channels = 0;
+
+    if (layer_stereo)
+    {
+        hDecoder->element_id[hDecoder->fr_ch_ele] = ID_CPE;
+    }
+    else
+    {
+        hDecoder->element_id[hDecoder->fr_ch_ele] = ID_SCE;
+    }
+
+    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)
+        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;
+
+    result = hdc_data_frame(hDecoder, ics1, ics2, ld, layer_stereo, 0, 0);
+    if (result > 0)
+    {
+        printf("failed at hdc_data_frame %d\n", result);
+        return result;
+    }
+
+    cpe->common_window = 1;
+    cpe->channel_index = channels;
+    cpe->num_channels = 1;
+
+    if (layer_stereo)
+    {
+        cpe->num_channels++;
+    }
+
+    // if (enh)
+    //     return 200;
+
+    ics1->tns_data_present = faad_get1bit(ld);
+    if (ics1->tns_data_present)
+        tns_data(hDecoder, ics1, &(ics1->tns), ld);
+    if (layer_stereo)
+    {
+        /* get tns data */
+        if ((ics2->tns_data_present = faad_get1bit(ld)) & 1)
+            tns_data(hDecoder, ics2, &(ics2->tns), ld);
+    }
+
+    result = side_info(hDecoder, cpe, ld, ics1, 1);
+    if (result > 0)
+    {
+        printf("side_info %d\n", result);
+        return result;
+    }
+
+    /* decode the spectral data */
+    if ((result = spectral_data(hDecoder, ics1, ld, spec_data1)) > 0)
+    {
+        printf("spectral_data %d\n", result);
+        return result;
+    }
+    if (layer_stereo)
+    {
+        result = side_info(hDecoder, cpe, ld, ics2, 1);
+        if (result > 0)
+        {
+            printf("side_info 2nd %d\n", result);
+            return result;
+        }
+
+        if ((result = spectral_data(hDecoder, ics2, ld, spec_data2)) > 0)
+            return result;
+    }
+    return 0;
+}
+
+void hdc_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,
+                    bitfile *ld, bitfile *enh, program_config *pce, drc_info *drc)
+{
+    uint8_t result;
+    uint8_t channels = hDecoder->fr_channels = 0;
+    uint8_t block_type, enh_block_type;
+    uint8_t layer_stereo, enh_layer_stereo = 0;
+    element cpe = {0};
+    element enh_cpe = {0};
+
+    hDecoder->fr_ch_ele = 0;
+    hDecoder->first_syn_ele = 25;
+    hDecoder->has_lfe = 0;
+
+    block_type = (uint8_t)faad_getbits(ld, LEN_SE_ID);
+    layer_stereo = hdc_is_stereo_layer(block_type);
+
+    //printf("HDC Block Type: %d\n", block_type);
+    hInfo->error = hdc_stream(hDecoder, hInfo, &cpe, ld, layer_stereo);
+    if (hInfo->error > 0)
+        return;
+
+    if (enh)
+    {
+        memcpy(&enh_cpe, &cpe, sizeof(cpe));
+        enh_layer_stereo = hdc_enhanced_is_stereo_layer(enh_block_type);
+
+        result = hdc_enhanced_stream(hDecoder, hInfo, &enh_cpe, enh,
+            enh_layer_stereo,
+            !layer_stereo && enh_layer_stereo,
+            !layer_stereo);
+        if (result > 0)
+        {
+            printf("Failed to parse HDC Enhanced Stream: %d\n", result);
+            enh = NULL;
+        }
+    }
+
+    /* check if next bitstream element is a fill element */
+    /* if so, read it now so SBR decoding can be done in case of a file with SBR */
+    if (faad_showbits(ld, LEN_SE_ID) == ID_FIL)
+    {
+        faad_flushbits(ld, LEN_SE_ID);
+
+        if (faad_getbits(ld, 1) && (hInfo->error = hdc_sbr_data_block(hDecoder, ld)) > 0)
+            return;
+    }
+
+    hInfo->error = reconstruct_scaled_channel(hDecoder, &cpe, enh ? &enh_cpe : NULL);
+    if (hInfo->error > 0)
+    {
+        printf("reconstruct_scaled_channel: %d\n", hInfo->error);
+        return;
+    }
+
+    // if (layer_stereo)
+    // {
+    //     hInfo->error = reconstruct_channel_pair(hDecoder, &cpe);
+    //     if (hInfo->error > 0)
+    //         return;
+    // } else {
+    //     hInfo->error = reconstruct_single_channel(hDecoder, &cpe);
+    //     if (hInfo->error > 0)
+    //         return;
+    // }
+
+    /* map output channels position to internal data channels */
+    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)
+    {
+        /* this might be faulty when pce_set is true */
+        hDecoder->internal_channel[channels] = channels;
+        hDecoder->internal_channel[channels+1] = channels+1;
+    } else {
+        hDecoder->internal_channel[channels] = channels;
+    }
+
+    hDecoder->fr_channels += hDecoder->element_output_channels[hDecoder->fr_ch_ele];
+    hDecoder->fr_ch_ele++;
+}
+#endif
+
 void raw_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,
                     bitfile *ld, program_config *pce, drc_info *drc)
 {
@@ -654,15 +1089,15 @@ static uint8_t single_lfe_channel_element(NeAACDecStruct *hDecoder, bitfile *ld,
 {
     uint8_t retval = 0;
     element sce = {0};
-    ic_stream *ics = &(sce.ics1);
-    ALIGN int16_t spec_data[1024] = {0};
+    ic_stream *ics = &(sce.channels[0].ics);
+    int16_t* spec_data = sce.channels[0].spec_data;

     sce.element_instance_tag = (uint8_t)faad_getbits(ld, LEN_TAG
         DEBUGVAR(1,38,"single_lfe_channel_element(): element_instance_tag"));

     *tag = sce.element_instance_tag;
-    sce.channel = channel;
-    sce.paired_channel = -1;
+    sce.channel_index = channel;
+    sce.num_channels = 1;

     retval = individual_channel_stream(hDecoder, &sce, ld, ics, 0, spec_data);
     if (retval > 0)
@@ -688,7 +1123,7 @@ static uint8_t single_lfe_channel_element(NeAACDecStruct *hDecoder, bitfile *ld,
 #endif

     /* noiseless coding is done, spectral reconstruction is done now */
-    retval = reconstruct_single_channel(hDecoder, ics, &sce, spec_data);
+    retval = reconstruct_single_channel(hDecoder, &sce);
     if (retval > 0)
         return retval;

@@ -699,15 +1134,15 @@ static uint8_t single_lfe_channel_element(NeAACDecStruct *hDecoder, bitfile *ld,
 static uint8_t channel_pair_element(NeAACDecStruct *hDecoder, bitfile *ld,
                                     uint8_t channels, uint8_t *tag)
 {
-    ALIGN int16_t spec_data1[1024] = {0};
-    ALIGN int16_t spec_data2[1024] = {0};
     element cpe = {0};
-    ic_stream *ics1 = &(cpe.ics1);
-    ic_stream *ics2 = &(cpe.ics2);
+    ic_stream *ics1 = &(cpe.channels[0].ics);
+    ic_stream *ics2 = &(cpe.channels[1].ics);
+    int16_t* spec_data1 = cpe.channels[0].spec_data;
+    int16_t* spec_data2 = cpe.channels[1].spec_data;
     uint8_t result;

-    cpe.channel        = channels;
-    cpe.paired_channel = channels+1;
+    cpe.channel_index  = channels;
+    cpe.num_channels   = 2;

     cpe.element_instance_tag = (uint8_t)faad_getbits(ld, LEN_TAG
         DEBUGVAR(1,39,"channel_pair_element(): element_instance_tag"));
@@ -816,8 +1251,7 @@ static uint8_t channel_pair_element(NeAACDecStruct *hDecoder, bitfile *ld,
 #endif

     /* noiseless coding is done, spectral reconstruction is done now */
-    if ((result = reconstruct_channel_pair(hDecoder, ics1, ics2, &cpe,
-        spec_data1, spec_data2)) > 0)
+    if ((result = reconstruct_channel_pair(hDecoder, &cpe)) > 0)
     {
         return result;
     }
@@ -1172,6 +1606,14 @@ static uint8_t fill_element(NeAACDecStruct *hDecoder, bitfile *ld, drc_info *drc
                 hDecoder->ps_used_global = 1;
             }
 #endif
+        } else if (bs_extension_type == 0) {
+            // padding
+            int i;
+            for (i = 0; i < count; i++)
+            {
+                if ((uint8_t)faad_getbits(ld, 8) != 0)
+                    fprintf(stderr, "sbr_extension_data: zero fil data not zero\n");
+            }
         } else {
 #endif
 #ifndef DRM
@@ -1300,10 +1742,10 @@ void DRM_aac_scalable_main_element(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *
     uint8_t channels = hDecoder->fr_channels = 0;
     uint8_t this_layer_stereo = (hDecoder->channelConfiguration > 1) ? 1 : 0;
     element cpe = {0};
-    ic_stream *ics1 = &(cpe.ics1);
-    ic_stream *ics2 = &(cpe.ics2);
-    ALIGN int16_t spec_data1[1024] = {0};
-    ALIGN int16_t spec_data2[1024] = {0};
+    ic_stream *ics1 = &(cpe.channels[0].ics);
+    ic_stream *ics2 = &(cpe.channels[1].ics);
+    int16_t* spec_data1 = cpe.channels[0].spec_data;
+    int16_t* spec_data2 = cpe.channels[1].spec_data;

     (void)drc;  /* TODO: remove unused parameter? */
     (void)pce;  /* TODO: remove unused parameter? */
@@ -1324,10 +1766,12 @@ void DRM_aac_scalable_main_element(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *
         hDecoder->element_id[0] = ID_SCE;
     }

+    cpe.channel_index  = 0;
+    cpe.num_channels   = 1;
+
     if (this_layer_stereo)
     {
-        cpe.channel        = 0;
-        cpe.paired_channel = 1;
+        cpe.num_channels++;
     }


@@ -1362,12 +1806,12 @@ void DRM_aac_scalable_main_element(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *
     }
     /* Stereo4 / Mono2 */
     if (ics1->tns_data_present)
-        tns_data(ics1, &(ics1->tns), ld);
+        tns_data(hDecoder, ics1, &(ics1->tns), ld);
     if (this_layer_stereo)
     {
         /* Stereo5 */
         if (ics2->tns_data_present)
-            tns_data(ics2, &(ics2->tns), ld);
+            tns_data(hDecoder, ics2, &(ics2->tns), ld);
     }

 #ifdef DRM
@@ -1483,11 +1927,11 @@ void DRM_aac_scalable_main_element(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *

     if (this_layer_stereo)
     {
-        hInfo->error = reconstruct_channel_pair(hDecoder, ics1, ics2, &cpe, spec_data1, spec_data2);
+        hInfo->error = reconstruct_channel_pair(hDecoder, &cpe);
         if (hInfo->error > 0)
             return;
     } else {
-        hInfo->error = reconstruct_single_channel(hDecoder, ics1, &cpe, spec_data1);
+        hInfo->error = reconstruct_single_channel(hDecoder, &cpe);
         if (hInfo->error > 0)
             return;
     }
@@ -1583,6 +2027,8 @@ static uint8_t side_info(NeAACDecStruct *hDecoder, element *ele,
     ics->global_gain = (uint8_t)faad_getbits(ld, 8
         DEBUGVAR(1,67,"individual_channel_stream(): global_gain"));

+    //printf("ics->global_gain: %d\n", ics->global_gain);
+
     if (!ele->common_window && !scal_flag)
     {
         if ((result = ics_info(hDecoder, ics, ld, ele->common_window)) > 0)
@@ -1617,7 +2063,7 @@ static uint8_t side_info(NeAACDecStruct *hDecoder, element *ele,
 #ifdef ERROR_RESILIENCE
             if (hDecoder->object_type < ER_OBJECT_START)
 #endif
-                tns_data(ics, &(ics->tns), ld);
+                tns_data(hDecoder, ics, &(ics->tns), ld);
         }

         /* get gain control data */
@@ -1681,7 +2127,7 @@ static uint8_t individual_channel_stream(NeAACDecStruct *hDecoder, element *ele,
     if (hDecoder->object_type >= ER_OBJECT_START)
     {
         if (ics->tns_data_present)
-            tns_data(ics, &(ics->tns), ld);
+            tns_data(hDecoder, ics, &(ics->tns), ld);
     }

 #ifdef DRM
@@ -1866,6 +2312,7 @@ static uint8_t section_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *l
          * group shall equal max_sfb */
         if (k != ics->max_sfb)
         {
+            printf("Expected max sfb of %d, got %d\n", ics->max_sfb, k);
             return 32;
         }
 #if 0
@@ -2016,7 +2463,7 @@ static uint8_t scale_factor_data(NeAACDecStruct *hDecoder, ic_stream *ics, bitfi
 }

 /* Table 4.4.27 */
-static void tns_data(ic_stream *ics, tns_info *tns, bitfile *ld)
+static void tns_data(NeAACDecStruct *hDecoder, ic_stream *ics, tns_info *tns, bitfile *ld)
 {
     uint8_t w, filt, i, coef_bits;
     uint8_t n_filt_bits = 2;
@@ -2033,6 +2480,11 @@ static void tns_data(ic_stream *ics, tns_info *tns, bitfile *ld)
     for (w = 0; w < ics->num_windows; w++)
     {
         uint8_t start_coef_bits = 3;
+#ifdef HDC
+        if (hDecoder->object_type == HDC_LC && ics->window_sequence != EIGHT_SHORT_SEQUENCE)
+            tns->n_filt[w] = 1;
+        else
+#endif
         tns->n_filt[w] = (uint8_t)faad_getbits(ld, n_filt_bits
             DEBUGVAR(1,74,"tns_data(): n_filt"));
 #if 0
diff --git a/libfaad/syntax.h b/libfaad/syntax.h
index b6311ed..7bc1ebc 100644
--- a/libfaad/syntax.h
+++ b/libfaad/syntax.h
@@ -46,6 +46,7 @@ extern "C" {
 #define ER_LC     17
 #define ER_LTP    19
 #define DRM_ER_LC 27 /* special object type for DRM */
+#define HDC_LC    127 /* special object type for HDC */

 /* header types */
 #define RAW        0
@@ -126,6 +127,11 @@ void DRM_aac_scalable_main_element(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *
 uint32_t faad_latm_frame(latm_header *latm, bitfile *ld);
 #endif

+#ifdef HDC
+void hdc_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,
+                    bitfile *ld, bitfile *enh, program_config *pce, drc_info *drc);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
